

import SwiftUI
import UIKit
import AVFoundation
import Foundation
import CoreLocation
import UserNotifications
import AudioToolbox
import MapKit

//import Adhan

// ÿ£ÿπŸÑŸâ ContentView.swiftÿå ŸÇÿ®ŸÑ:
// struct ContentView: View { ‚Ä¶ }



// MARK: - LocationManager (with Heading)
class LocationManager: NSObject, ObservableObject, CLLocationManagerDelegate {
    @Published var location: CLLocation?
    @Published var placemark: CLPlacemark?
    @Published var heading: CLHeading?

    private let manager = CLLocationManager()

    // ‚Üê ŸáŸÜÿß ŸÜÿ∂ŸäŸÅ authStatus
    var authStatus: CLAuthorizationStatus {
        if #available(iOS 14.0, *) {
            return manager.authorizationStatus
        } else {
            return CLLocationManager.authorizationStatus()
        }
    }

    override init() {
        super.init()
        manager.delegate = self
        manager.desiredAccuracy = kCLLocationAccuracyBest
        manager.headingFilter = kCLHeadingFilterNone
        manager.requestWhenInUseAuthorization()
        manager.startUpdatingLocation()
        manager.startUpdatingHeading()
    }

    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        if location == nil, let loc = locations.last {
            DispatchQueue.main.async { self.location = loc }
            CLGeocoder().reverseGeocodeLocation(loc) { places, _ in
                if let place = places?.first {
                    DispatchQueue.main.async { self.placemark = place }
                }
            }
        }
    }

    func locationManager(_ manager: CLLocationManager, didUpdateHeading newHeading: CLHeading) {
        DispatchQueue.main.async { self.heading = newHeading }
    }
}
// MARK: - Bearing Calculation
private let kaabaLatitude  = 21.4225
private let kaabaLongitude = 39.8262

extension Double {
    func toRadians() -> Double { self * .pi / 180 }
    func toDegrees() -> Double { self * 180 / .pi }
}

extension Color {
    static let slateGray = Color(
        red:   113/255,
        green: 125/255,
        blue:  125/255
    )
}

func qiblaBearing(from loc: CLLocation) -> CLLocationDirection {
    let œÜ1 = loc.coordinate.latitude.toRadians()
    let Œª1 = loc.coordinate.longitude.toRadians()
    let œÜ2 = kaabaLatitude.toRadians()
    let Œª2 = kaabaLongitude.toRadians()
    let ŒîŒª = Œª2 - Œª1
    let y = sin(ŒîŒª) * cos(œÜ2)
    let x = cos(œÜ1)*sin(œÜ2) - sin(œÜ1)*cos(œÜ2)*cos(ŒîŒª)
    let Œ∏ = atan2(y, x).toDegrees()
    return fmod(Œ∏ + 360, 360)
}

// MARK: - CompassView
struct CompassView: View {
    let heading: CLLocationDirection?
    let bearing: CLLocationDirection?
    @State private var pulse = false

    var body: some View {
        ZStack {
            Circle()
                .fill(Color.white.opacity(0.7))
                .frame(width: 80, height: 80)
            ForEach(0..<12) { i in
                Capsule()
                    .fill(Color.black)
                    .frame(width: 2.0, height: i % 3 == 0 ? 10 : 5)
                    .offset(y: -25)
                    .rotationEffect(.degrees(Double(i) * 30))
            }
            Image(systemName: "arrowtriangle.up.fill")
                .resizable()
                .scaledToFit()
                .frame(width: 10, height: 20)
                .foregroundColor(.red)
                .offset(y: -9)
                .rotationEffect(.degrees(rotationAngle))
            Circle()
                .fill(isAligned ? Color.green : Color.white)
                .frame(width: 4, height: 4)
                .scaleEffect(pulse ? 1.5 : 1)
                .opacity(pulse ? 0.5 : 1)
                .animation(.easeInOut(duration: 1).repeatForever(), value: pulse)
        }
        .frame(width: 80, height: 60)
        .onAppear { pulse = true }
        .onChange(of: isAligned) { aligned in
            if aligned {
                UINotificationFeedbackGenerator().notificationOccurred(.success)
            }
        }
    }

    private var rotationAngle: Double {
        guard let h = heading, let b = bearing else { return 0 }
        return b - h
    }

    private var isAligned: Bool {
        guard let h = heading, let b = bearing else { return false }
        let diff = abs((b - h + 360).truncatingRemainder(dividingBy: 360))
        return diff <= 5 || diff >= 355
    }
}

// MARK: - EnhancedCompassView


struct EnhancedCompassView: View {
    let heading: CLLocationDirection?
    let bearing: CLLocationDirection?
    @State private var pulseScale: CGFloat = 1.0
    @State private var glowIntensity: CGFloat = 0

    let gradientColors = Gradient(colors: [
        Color(red: 0.1, green: 0.4, blue: 0.6),
        Color(red: 0.2, green: 0.4, blue: 0.4),
        Color.blue,
        Color(red: 0.4, green: 0.4, blue: 0.4),
        Color(red: 0.1, green: 0.4, blue: 0.6)
    ])








var body: some View {
    ZStack {
        // ÿßŸÑÿÆŸÑŸÅŸäÿ©
        Circle()
            .fill(
                AngularGradient(
                    gradient: gradientColors,
                    center: .center,
                    startAngle: .degrees(0),
                    endAngle: .degrees(360)
                )
            )
            .frame(width: 70, height: 70)
            .overlay(Circle().stroke(Color.white.opacity(0.3), lineWidth: 1))
            .shadow(color: Color.blue.opacity(0.4), radius: glowIntensity * 5)

        // ÿßŸÑÿßÿ™ÿ¨ÿßŸáÿßÿ™
        ForEach(0..<36) { i in
            if i % 9 == 0 {
                CompassDirectionMark(index: i)
            } else {
                Capsule()
                    .fill(i % 3 == 0 ? Color.white : Color.white.opacity(0.7))
                    .frame(width: i % 3 == 0 ? 1.2 : 0.8, height: i % 3 == 0 ? 5 : 3)
                    .offset(y: -40)
                    .rotationEffect(.degrees(Double(i) * 10))
            }
        }

        // ÿßŸÑÿ≥ŸáŸÖ ÿßŸÑÿ£ÿ≠ŸÖÿ±
        Image(systemName: "location.north.fill")
            .resizable()
            .scaledToFit()
            .frame(width: 17, height: 17)
            .foregroundColor(.red)
            .rotationEffect(.degrees(rotationAngle))
            .shadow(color: .red, radius: glowIntensity * 3)

        // ÿßŸÑŸÉÿπÿ®ÿ© ÿ®ÿßŸÑÿ£ÿπŸÑŸâ
        VStack {
            Text("üïã")
                .font(.system(size: 16))
                .padding(.bottom, 32)
            Spacer()
        }

        // ÿßŸÑŸÖÿ±ŸÉÿ≤ ÿßŸÑŸÜÿßÿ®ÿ∂
        Circle()
            .fill(Color.white.opacity(0.2))
            .frame(width: 10, height: 10)
            .overlay(
                Circle()
                    .fill(isAligned ? Color.green : Color.white)
                    .frame(width: 6, height: 6)
                    .scaleEffect(pulseScale)
                    .animation(
                        Animation.easeInOut(duration: 1.5).repeatForever(autoreverses: true),
                        value: pulseScale
                    )
            )
    }
    .frame(width: 80, height: 80)
    .offset(x: 10)
    .onAppear {
        pulseScale = 1.2
        animateGlow()
    }
.onChange(of: isAligned) { aligned in
    if aligned {
        // UINotificationFeedbackGenerator() ÿ™ŸÖ ÿ≠ÿ∞ŸÅŸá ÿπÿ¥ÿßŸÜ ŸÖÿß ŸäÿµŸäÿ± Ÿáÿ≤ÿßÿ≤
        animateGlow()
    }
}
}

    private var rotationAngle: Double {
        guard let h = heading, let b = bearing else { return 0 }
        return b - h
    }

    private var isAligned: Bool {
        guard let h = heading, let b = bearing else { return false }
        let diff = abs((b - h + 360).truncatingRemainder(dividingBy: 360))
        return diff <= 3 || diff >= 357
    }

    private func animateGlow() {
        withAnimation(Animation.easeInOut(duration: 1.5).repeatForever()) {
            glowIntensity = isAligned ? 1 : 0.3
        }
    }

    @ViewBuilder
    private func CompassDirectionMark(index: Int) -> some View {
        VStack {
            Text(directionLetter(for: index))
                .font(.system(size: 8, weight: .bold))
                .foregroundColor(.white)
                .shadow(color: .black, radius: 2.5)

            Capsule()
                .fill(Color.white)
                .frame(width: 2.5, height: 10)
                .offset(y: -3)
        }
        .offset(y: -42)
        .rotationEffect(.degrees(Double(index) * 10))
    }

    private func directionLetter(for index: Int) -> String {
        switch index {
        case 0: return "N"
        case 9: return "E"
        case 18: return "S"
        case 27: return "W"
        default: return ""
        }
    }
}
// MARK: - Prayer Times Models & Service
struct Timings: Codable {
    let fajr: String
    let sunrise: String      // ‚Üê ÿ£ÿ∂ŸÅ Ÿáÿ∞ÿß ÿßŸÑÿ≥ÿ∑ÿ±
    let dhuhr: String
    let asr: String
    let maghrib: String
    let isha: String

    private enum CodingKeys: String, CodingKey {
        case fajr     = "Fajr"
        case sunrise  = "Sunrise"   // ‚Üê ÿ£ÿ∂ŸÅ Ÿáÿ∞ÿß ÿßŸÑÿ≥ÿ∑ÿ±
        case dhuhr    = "Dhuhr"
        case asr      = "Asr"
        case maghrib  = "Maghrib"
        case isha     = "Isha"
    }
}
struct CoordinatesPrayerResponse: Codable { let data: CoordinateData }
struct CoordinateData: Codable { let timings: Timings; let date: DateInfo? }
struct DateInfo: Codable { let gregorian: Gregorian }
struct Gregorian: Codable { let day: String, month: Month, year: String }
struct Month: Codable { let number: Int }

class PrayerTimesService {
    static let shared = PrayerTimesService()
    private let baseCoordURL = "https://api.aladhan.com/v1/timings"

    func getPrayerTimesByCoordinates(latitude: Double,
                                     longitude: Double,
                                     completion: @escaping (Result<Timings, Error>) -> Void) {
        var comps = URLComponents(string: baseCoordURL)!
        comps.queryItems = [
            URLQueryItem(name: "latitude",  value: "\(latitude)"),
            URLQueryItem(name: "longitude", value: "\(longitude)"),
            URLQueryItem(name: "method",    value: "2")
        ]
        URLSession.shared.dataTask(with: comps.url!) { data, _, err in
            if let e = err { return completion(.failure(e)) }
            guard let d = data else {
                let noData = NSError(domain: "", code: -1,
                                     userInfo: [NSLocalizedDescriptionKey:"No data"])
                return completion(.failure(noData))
            }
            do {
                let resp = try JSONDecoder().decode(CoordinatesPrayerResponse.self, from: d)
                completion(.success(resp.data.timings))
            } catch {
                completion(.failure(error))
            }
        }.resume()
    }
}

// MARK: - SoundPlayer & ButtonStyle
class SoundPlayer {
    static let shared = SoundPlayer()
    private var players: [String: AVAudioPlayer] = [:]

    private init() {
        let session = AVAudioSession.sharedInstance()
        // ŸÜÿ¨ÿπŸÑ ÿßŸÑÿµŸàÿ™ Ÿäÿ™ÿ®ÿπ Ÿàÿ∂ÿπ ÿßŸÑÿµÿßŸÖÿ™
        try? session.setCategory(.soloAmbient, mode: .default, options: [])
        try? session.setActive(true)

        ["click","counter","complete"].forEach {
            if let url = Bundle.main.url(forResource: $0, withExtension: "mp3"),
               let p   = try? AVAudioPlayer(contentsOf: url) {
                p.prepareToPlay()
                players[$0] = p
            }
        }
    }

    func play(_ sound: String) {
        guard let p = players[sound] else { return }
        p.currentTime = 0
        p.play()
    }
}

struct SoundButtonStyle: ButtonStyle {
    @AppStorage("soundEnabled")  private var soundEnabled  = false
    @AppStorage("hapticEnabled") private var hapticEnabled = true

    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .scaleEffect(configuration.isPressed ? 0.95 : 1.0)
            .onChange(of: configuration.isPressed) { pressed in
                guard pressed else { return }
                if soundEnabled  { SoundPlayer.shared.play("click") }
                if hapticEnabled { UIImpactFeedbackGenerator(style: .light).impactOccurred() }
            }
    }
}
// MARK: - ScaleButtonStyle

struct ScaleButtonStyle: ButtonStyle {
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .scaleEffect(configuration.isPressed ? 0.95 : 1.0)
            .animation(.spring(), value: configuration.isPressed)
    }
}

// MARK: - Dhikr Model & ActivityView

struct Dhikr: Identifiable, Codable {
    var id = UUID()
    var text: String
    var repetition: Int
    var note: String?
}
struct ActivityView: UIViewControllerRepresentable {
    let activityItems: [Any]
    func makeUIViewController(context: Context) -> UIActivityViewController {
        UIActivityViewController(activityItems: activityItems, applicationActivities: nil)
    }
    func updateUIViewController(_ vc: UIActivityViewController, context: Context) {}
}
// MARK: - ClockView (static, 12-hour)
struct ClockView: View {
    private let now = Date()
    private let formatter: DateFormatter = {
        let f = DateFormatter()
        f.locale = Locale(identifier: "en_US_POSIX")
        f.dateFormat = "h:mm a"
        f.amSymbol = "ÿµ"
        f.pmSymbol = "ŸÖ"
        return f
    }()

    var body: some View {
        Text(formatter.string(from: now))
            .font(.system(size: 24, weight: .bold, design: .monospaced))
            .foregroundColor(.blue)
    }
}



// MARK: - ContentView


// MARK: - Offline Prayer Times Service
//ŸáŸÜÿß ÿ≥ŸÜŸá




/// ŸÜŸÖŸàÿ∞ÿ¨ ŸÑÿ™ŸÖÿ´ŸäŸÑ ÿ£ŸàŸÇÿßÿ™ ÿßŸÑÿµŸÑÿßÿ© ŸÉŸÜÿµŸàÿµ ÿ®ÿµŸäÿ∫ÿ© "HH:mm"





class PrayerTimesServiceOffline: NSObject, CLLocationManagerDelegate {
    static let shared = PrayerTimesServiceOffline()
    private let locationManager = CLLocationManager()
    private var completion: ((Timings) -> Void)?
    private var calculationDate: Date = Date()

    private override init() {
        super.init()
        locationManager.delegate = self
        locationManager.desiredAccuracy = kCLLocationAccuracyBestForNavigation
    }

    func getPrayerTimes(date: Date = Date(),
                        completion: @escaping (Timings) -> Void) {
        self.completion = completion
        self.calculationDate = date
        locationManager.requestWhenInUseAuthorization()
        locationManager.startUpdatingLocation()
    }

    func locationManager(_ manager: CLLocationManager,
                         didUpdateLocations locations: [CLLocation]) {
        manager.stopUpdatingLocation()
        guard let loc = locations.last else { return }

        let timings = calculateTimings(
            latitude:  loc.coordinate.latitude,
            longitude: loc.coordinate.longitude,
            date:      calculationDate
        )
        completion?(timings)
        completion = nil
    }

    func locationManager(_ manager: CLLocationManager,
                         didFailWithError error: Error) {
        manager.stopUpdatingLocation()
        let defaultLat = 35.78056
        let defaultLon = -78.6389

        let timings = calculateTimings(
            latitude:  defaultLat,
            longitude: defaultLon,
            date:      calculationDate
        )
        completion?(timings)
        completion = nil
    }

    private func calculateTimings(latitude: Double,
                                  longitude: Double,
                                  date: Date) -> Timings {
        let calendar = Calendar(identifier: .gregorian)
        let comps = calendar.dateComponents([.year, .month, .day], from: date)

        let coordinates = Coordinates(latitude: latitude, longitude: longitude)
        var params = CalculationMethod.muslimWorldLeague.params
        params.madhab = .shafi

        guard let prayerTimes = PrayerTimes(coordinates: coordinates,
                                            date: comps,
                                            calculationParameters: params) else {
            return Timings(fajr: "00:00", sunrise: "00:00",
                           dhuhr: "00:00", asr: "00:00",
                           maghrib: "00:00", isha: "00:00")
        }

        // ÿ≠ÿ≥ÿßÿ® SunnahTimes
        if let sunnahTimes = SunnahTimes(from: prayerTimes) {
            let formatter = DateFormatter()
            formatter.locale = Locale(identifier: "en_US_POSIX")
            formatter.timeZone = TimeZone.current
            formatter.dateFormat = "HH:mm"

            print("Last Third of the Night: \(formatter.string(from: sunnahTimes.lastThirdOfTheNight))")
            print("Middle of the Night: \(formatter.string(from: sunnahTimes.middleOfTheNight))")
        }

        // ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑÿµŸÑÿßÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ© ŸàÿßŸÑŸÇÿßÿØŸÖÿ© ŸàÿßŸÑŸàŸÇÿ™ ÿßŸÑŸÖÿ™ÿ®ŸÇŸä
        let currentPrayer = prayerTimes.currentPrayer()
        let nextPrayer = prayerTimes.nextPrayer()
let countdown = nextPrayer.flatMap { prayerTimes.time(for: $0).timeIntervalSinceNow } ?? 0

        print("Current Prayer: \(String(describing: currentPrayer))")
        print("Next Prayer: \(String(describing: nextPrayer))")
        print("Time until next prayer: \(countdown)")

        func fmt(_ date: Date) -> String {
            let formatter = DateFormatter()
            formatter.locale     = Locale(identifier: "en_US_POSIX")
            formatter.timeZone   = TimeZone.current
            formatter.dateFormat = "HH:mm"
            return formatter.string(from: date)
        }

        return Timings(
            fajr:    fmt(prayerTimes.fajr),
            sunrise: fmt(prayerTimes.sunrise),
            dhuhr:   fmt(prayerTimes.dhuhr),
            asr:     fmt(prayerTimes.asr),
            maghrib: fmt(prayerTimes.maghrib),
            isha:    fmt(prayerTimes.isha)
        )
    }
}


// ÿ£ÿπŸÑŸâ ContentView.swift
private struct DefaultIqamaOffsets {
    let fajr: Int    = 20
    let dhuhr: Int   = 20
    let asr: Int     = 20
    let maghrib: Int = 10
    let isha: Int    = 20
}
private let defaultIqamaOffsets = DefaultIqamaOffsets()


//ŸáŸÜÿß3

struct ContentView: View {

@State private var lastFetchedDay = Calendar.current.startOfDay(for: Date())


    // MARK: ‚Äì App Settings
    @AppStorage("darkModeEnabled") private var darkModeEnabled = true
    @AppStorage("soundEnabled")    private var soundEnabled    = false
    @AppStorage("hapticEnabled")   private var hapticEnabled   = true
    
    // ŸÉÿ™ŸÖ ÿßŸÑÿ£ÿ∞ÿßŸÜ
    @AppStorage("muteAzanFajr")    private var muteAzanFajr    = false
    @AppStorage("muteAzanDhuhr")   private var muteAzanDhuhr   = false
    @AppStorage("muteAzanAsr")     private var muteAzanAsr     = false
    @AppStorage("muteAzanMaghrib") private var muteAzanMaghrib = false
    @AppStorage("muteAzanIsha")    private var muteAzanIsha    = false
    
    @AppStorage("muteAzanSunrise") private var muteAzanSunrise   = false
    
    
    
    // ŸÉÿ™ŸÖ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™
    @AppStorage("muteNotifSunrise") private var muteNotifSunrise = false
    
    @AppStorage("muteNotifFajr")    private var muteNotifFajr    = false
    @AppStorage("muteNotifDhuhr")   private var muteNotifDhuhr   = false
    @AppStorage("muteNotifAsr")     private var muteNotifAsr     = false
    @AppStorage("muteNotifMaghrib") private var muteNotifMaghrib = false
    @AppStorage("muteNotifIsha")    private var muteNotifIsha    = false
    
    
    @AppStorage("notificationsEnabled") private var notificationsEnabled = true
    
    // ÿØŸÇÿßÿ¶ŸÇ ÿßŸÑÿ•ŸÇÿßŸÖÿ©
    @AppStorage("iqamaFajrOffset")    private var iqamaFajrOffset    = 20
    @AppStorage("iqamaDhuhrOffset")   private var iqamaDhuhrOffset   = 20
    @AppStorage("iqamaAsrOffset")     private var iqamaAsrOffset     = 20
    @AppStorage("iqamaMaghribOffset") private var iqamaMaghribOffset = 10
    @AppStorage("iqamaIshaOffset")    private var iqamaIshaOffset    = 20


    // MARK: ‚Äì ÿ™ÿ£ÿÆŸäÿ±/ÿ™ŸÇÿØŸäŸÖ ŸÖŸàÿπÿØ ÿßŸÑÿ£ÿ∞ÿßŸÜ (ÿ®ÿßŸÑÿØŸÇÿßÿ¶ŸÇ)
    @AppStorage("azanFajrOffset")    private var azanFajrOffset    = 0
    @AppStorage("azanDhuhrOffset")   private var azanDhuhrOffset   = 0
    @AppStorage("azanAsrOffset")     private var azanAsrOffset     = 0
    @AppStorage("azanMaghribOffset") private var azanMaghribOffset = 0
    @AppStorage("azanIshaOffset")    private var azanIshaOffset    = 0
    @AppStorage("azanSunriseOffset") private var azanSunriseOffset = 0

@AppStorage("selectedLanguage")
private var selectedLanguage: String = Locale.current.language.languageCode?.identifier ?? "en"



@Environment(\.layoutDirection) var layoutDirection

@Environment(\.locale) private var locale

@State private var tempIqamaFajrOffset    = 0
@State private var tempIqamaDhuhrOffset   = 0
@State private var tempIqamaAsrOffset     = 0
@State private var tempIqamaMaghribOffset = 0
@State private var tempIqamaIshaOffset    = 0

@State private var tempAzanFajrOffset    = 0
@State private var tempAzanSunriseOffset = 0
@State private var tempAzanDhuhrOffset   = 0
@State private var tempAzanAsrOffset     = 0
@State private var tempAzanMaghribOffset = 0
@State private var tempAzanIshaOffset    = 0






// ÿ£ÿ∂ŸÅ Ÿáÿ∞Ÿá ÿßŸÑŸÖÿ™ÿ∫ŸäŸëÿ±ÿßÿ™ ŸÑÿ≠ŸÅÿ∏ ÿßŸÑÿ≥ÿßÿπÿ© ÿßŸÑÿ£ÿµŸÑŸäÿ© ÿ®ÿµŸäÿ∫ÿ© 12-ÿ≥ÿßÿπÿ©
@State private var origFajr    = ""
@State private var origSunrise = ""
@State private var origDhuhr   = ""
@State private var origAsr     = ""
@State private var origMaghrib = ""
@State private var origIsha    = ""
    
    
    private let badgeColors: [Color] = [
        .green, .orange, .blue, .red, .purple, .pink, .yellow
    ]
    
    //@State private var customSections: [String] = UserDefaults.standard.stringArray(forKey: "customSections") ?? []
    //@State private var showAddSection = false
    //@State private var newSectionName = ""
    
    // ÿ≠ÿßŸÑŸÄŸÄÿ© ÿßŸÑŸÄ UI
    @State private var showSettings  = false
    @State private var showEditIqama = false
@State private var settingsTimings: Timings?   // ŸÑÿ•ÿπÿßÿØÿ© ÿßŸÑÿ≠ÿ≥ÿßÿ® ŸÅŸä ÿ¥ÿßÿ¥ÿ© ÿßŸÑÿ™ÿπÿØŸäŸÑ
    
    @State private var deleteIndex: Int? = nil
    //@State private var showDeleteAlert = false
    
    
    
    
    //@State private var deleteSectionIndex: Int? = nil
    
    
    
    
    // ÿßŸÑŸÖŸàŸÇÿπ ŸàŸÖŸàÿßŸÇŸäÿ™ ÿßŸÑÿµŸÑÿßÿ©
    @StateObject private var locationManager = LocationManager()
    @State private var prayerTimes: Timings?
    @State private var isLoading = true
    @State private var now       = Date()
    
    
    
    
    
    
    
    // ‚Ä¶
    
    
    
    
    
    // ... ŸÖÿ≠ÿ™ŸàŸâ ÿßŸÑŸàÿßÿ¨Ÿáÿ© ...
    
    
    // ÿØÿßÿÆŸÑ ContentViewÿå ÿ®ÿπÿØ ŸÖÿß ÿ™ÿ¨Ÿäÿ® prayerTimes Ÿà now:
    private var nextPrayerIndex: Int {
        guard let t = prayerTimes else { return 0 }
        let cal = Calendar.current
        let startOfDay = cal.startOfDay(for: now)
        let offset: TimeInterval = 30 * 60
        
        // ÿßŸÑÿ¢ŸÜ ÿ™ÿ¥ŸÖŸÑ Sunrise ÿ£Ÿäÿ∂ÿßŸã
        let rawTimes = [t.fajr, t.sunrise, t.dhuhr, t.asr, t.maghrib, t.isha]
        let prayerDates: [Date] = rawTimes.compactMap { timeStr in
            let clean = timeStr
                .trimmingCharacters(in: .whitespacesAndNewlines)
                .components(separatedBy: .whitespaces).first ?? timeStr
            guard let d = parser.date(from: clean) else { return nil }
            return cal.date(
                bySettingHour: cal.component(.hour,   from: d),
                minute:        cal.component(.minute, from: d),
                second:        0,
                of:            startOfDay
            )
        }
        
        for (i, pd) in prayerDates.enumerated() {
            if now < pd || now < pd + offset {
                return i
            }
        }
        
        return 0
    }


// ÿØÿßÿÆŸÑ ContentViewÿå ŸÅŸàŸÇ var body
private func adjustedAzanTime(_ timeString: String, for prayer: String) -> String {
    guard let originalDate = parser.date(from: timeString) else { return timeString }

    // ÿßŸÑÿ•ÿ≤ÿßÿ≠ÿ©
    let offset: Int
    switch prayer {
    case "ÿßŸÑŸÅÿ¨ÿ±", "Fajr":       offset = azanFajrOffset
    case "ÿßŸÑÿ¥ÿ±ŸàŸÇ", "Sunrise":   offset = azanSunriseOffset
    case "ÿßŸÑÿ∏Ÿáÿ±", "Dhuhr":      offset = azanDhuhrOffset
    case "ÿßŸÑÿπÿµÿ±", "Asr":        offset = azanAsrOffset
    case "ÿßŸÑŸÖÿ∫ÿ±ÿ®", "Maghrib":   offset = azanMaghribOffset
    case "ÿßŸÑÿπÿ¥ÿßÿ°", "Isha":      offset = azanIshaOffset
    default:                    offset = 0
    }

    let adjustedDate = Calendar.current.date(byAdding: .minute, value: offset, to: originalDate) ?? originalDate

    // ŸÖŸáŸäÿ¶ ÿßŸÑÿ™ÿßÿ±ŸäÿÆ ÿ≠ÿ≥ÿ® ÿßŸÑŸÑÿ∫ÿ©
    let formatter = DateFormatter()
    formatter.locale = Locale(identifier: "en_US_POSIX")
    formatter.dateFormat = "h:mm a"
    
    if selectedLanguage == "ar" {
        formatter.amSymbol = "ÿµ"
        formatter.pmSymbol = "ŸÖ"
    } else {
        formatter.amSymbol = "AM"
        formatter.pmSymbol = "PM"
    }

    return formatter.string(from: adjustedDate)
}
    // ÿßÿ∂ÿ®ÿ∑ ÿßŸÑÿ≥ÿßÿπÿ© ÿßŸÑŸÇÿØŸäŸÖÿ© ŸÖÿπ ÿßŸÑÿØŸÇŸäŸÇÿ© ÿßŸÑÿ¨ÿØŸäÿØÿ©

    
    
    // 1) ŸÅŸàŸÇ ÿßŸÑŸÄ body (ÿ∂ŸÖŸÜ ContentView) ÿ£ÿ∂ŸÅ ÿßŸÑÿØŸàÿßŸÑ Ÿáÿ∞Ÿä:
    private func isAzanMuted(for prayer: String) -> Bool {
        switch prayer {
        case "ÿßŸÑŸÅÿ¨ÿ±":  return muteAzanFajr
        case "ÿßŸÑÿ¥ÿ±ŸàŸÇ": return muteAzanSunrise
        case "ÿßŸÑÿ∏Ÿáÿ±":  return muteAzanDhuhr
        case "ÿßŸÑÿπÿµÿ±":  return muteAzanAsr
        case "ÿßŸÑŸÖÿ∫ÿ±ÿ®": return muteAzanMaghrib
        case "ÿßŸÑÿπÿ¥ÿßÿ°": return muteAzanIsha
        default:       return false
        }
    }
    
    private func toggleAzanMute(for prayer: String) {
        switch prayer {
        case "ÿßŸÑŸÅÿ¨ÿ±":  muteAzanFajr.toggle()
        case "ÿßŸÑÿ¥ÿ±ŸàŸÇ": muteAzanSunrise.toggle()
        case "ÿßŸÑÿ∏Ÿáÿ±":  muteAzanDhuhr.toggle()
        case "ÿßŸÑÿπÿµÿ±":  muteAzanAsr.toggle()
        case "ÿßŸÑŸÖÿ∫ÿ±ÿ®": muteAzanMaghrib.toggle()
        case "ÿßŸÑÿπÿ¥ÿßÿ°": muteAzanIsha.toggle()
        default: break
        }
        if let t = prayerTimes { schedulePrayerNotifications(t) }
    }
    
    private func isNotifMuted(for prayer: String) -> Bool {
        switch prayer {
        case "ÿßŸÑŸÅÿ¨ÿ±":  return muteNotifFajr
        case "ÿßŸÑÿ¥ÿ±ŸàŸÇ": return muteNotifSunrise
        case "ÿßŸÑÿ∏Ÿáÿ±":  return muteNotifDhuhr
        case "ÿßŸÑÿπÿµÿ±":  return muteNotifAsr
        case "ÿßŸÑŸÖÿ∫ÿ±ÿ®": return muteNotifMaghrib
        case "ÿßŸÑÿπÿ¥ÿßÿ°": return muteNotifIsha
        default:       return false
        }
    }
    
    private func toggleNotifMute(for prayer: String) {
        switch prayer {
        case "ÿßŸÑŸÅÿ¨ÿ±":  muteNotifFajr.toggle()
        case "ÿßŸÑÿ¥ÿ±ŸàŸÇ": muteNotifSunrise.toggle()
        case "ÿßŸÑÿ∏Ÿáÿ±":  muteNotifDhuhr.toggle()
        case "ÿßŸÑÿπÿµÿ±":  muteNotifAsr.toggle()
        case "ÿßŸÑŸÖÿ∫ÿ±ÿ®": muteNotifMaghrib.toggle()
        case "ÿßŸÑÿπÿ¥ÿßÿ°": muteNotifIsha.toggle()
        default: break
        }
        if let t = prayerTimes { schedulePrayerNotifications(t) }
    }
    
    // 2) ÿØÿßÿÆŸÑ ForEachÿå ÿ∫ŸäŸëÿ± HStack ŸÉÿ∞ÿß:
    
// MARK: ‚Äì Localized Date/Time/Location

private var isArabic: Bool {
    locale.language.languageCode?.identifier == "ar"
}

private var localizedTime: String {
    let f = DateFormatter()
    f.locale = Locale(identifier: "en_US_POSIX")
    f.dateFormat = "h:mm a"
    if isArabic {
        f.amSymbol = "ÿµ"; f.pmSymbol = "ŸÖ"
    }
    return f.string(from: now)
}

private var localizedWeekday: String {
    let f = DateFormatter()
    f.locale = Locale(identifier: isArabic ? "ar" : "en_US_POSIX")
    f.dateFormat = "EEEE"
    return f.string(from: now)
}

private var localizedDate: String {
    let f = DateFormatter()
    f.locale = Locale(identifier: isArabic ? "ar" : "en_US_POSIX")
    // ŸäŸÖŸÉŸÜŸÉ ÿ™ÿ∫ŸäŸäÿ± ÿßŸÑÿµŸäÿ∫ÿ© ÿ≠ÿ≥ÿ® ÿ±ÿ∫ÿ®ÿ™ŸÉ
    f.dateFormat = isArabic ? "d/MMMM/yyyy" : "MMMM d, yyyy"
    return f.string(from: now)
}

private var localizedHijri: String {
    let f = DateFormatter()
    f.calendar = Calendar(identifier: .islamicUmmAlQura)
    f.locale   = Locale(identifier: isArabic ? "ar" : "en_US_POSIX")
    f.dateFormat = "d MMMM yyyy"
    return f.string(from: now)
}

private var localizedLocation: String {
    guard let place = locationManager.placemark else { return "‚Ä¶" }
    let city = place.locality ?? "‚Ä¶"
    let country: String
    if let code = place.isoCountryCode {
        // ÿØÿßÿ¶ŸÖŸãÿß ÿßÿ≠ÿµŸÑ ÿπŸÑŸâ ÿßÿ≥ŸÖ ÿßŸÑÿ®ŸÑÿØ ÿ®ÿßŸÑÿ•ŸÜÿ¨ŸÑŸäÿ≤Ÿäÿ©
        country = Locale(identifier: "en_US_POSIX")
            .localizedString(forRegionCode: code) ?? place.country ?? "‚Ä¶"
    } else {
        country = place.country ?? "‚Ä¶"
    }
    return isArabic
        ? "\(city)ÿå \(country)"
        : "\(city), \(country)"
}



    

    // MARK: ‚Äì Timer
    private let timer = Timer.publish(every: 1, on: .main, in: .common).autoconnect()
    
    // MARK: ‚Äì Date Formatters
    private let parser: DateFormatter = {
        let f = DateFormatter()
        f.locale = Locale(identifier: "en_US_POSIX")
        f.dateFormat = "HH:mm"
        return f
    }()
    
    // ÿØÿßÿÆŸÑ ContentView (ŸÅŸàŸÇ ÿßŸÑŸÄ body)
    

    private let weekdayFormatter: DateFormatter = {
        let f = DateFormatter()
        f.locale = Locale(identifier: "ar")
        f.dateFormat = "EEEE"
        return f
    }()
    // ÿ™ÿßÿ±ŸäÿÆ ŸÖŸÅÿµŸàŸÑ ÿ®ÿ¥ÿ±ÿ∑ÿßÿ™ ŸÖÿπ ÿ≥ŸÜÿ©
    private let slashDateFormatter: DateFormatter = {
        let f = DateFormatter()
        f.locale = Locale(identifier: "ar")
        f.dateFormat = "d/MMMM/yyyy"
        return f
    }()
    private let formatter12: DateFormatter = {
        let f = DateFormatter()
        f.locale = Locale(identifier: "en_US_POSIX")
        f.dateFormat = "h:mm a"
        f.amSymbol = "ÿµ"; f.pmSymbol = "ŸÖ"
        return f
    }()
    
    // ÿØÿßÿÆŸÑ ContentView (ŸÅŸàŸÇ ÿßŸÑŸÄ body)
    private let hijriDateFormatter: DateFormatter = {
        let f = DateFormatter()
        f.locale = Locale(identifier: "ar")
        f.calendar = Calendar(identifier: .islamicUmmAlQura)
        f.dateFormat = "d MMMM yyyy"
        return f
    }()

    
    // MARK: ‚Äì Helper Functions
    private func formatTime(_ time: String) -> String {
        let clean = time
            .trimmingCharacters(in: .whitespacesAndNewlines)
            .components(separatedBy: .whitespaces).first ?? time
        guard let date = parser.date(from: clean) else { return clean }
        return formatter12.string(from: date)
    }
    
    
    // MARK: ‚Äì ÿπÿØŸëÿßÿØ ÿßŸÑÿØŸÇÿßÿ¶ŸÇ ÿ≠ÿ™Ÿâ ÿßŸÑÿµŸÑÿßÿ©
    private func countdownSeconds(for timeString: String, prayer: String) -> Int? {
        // ŸÜÿπŸäÿØ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ parsed Ÿà rawAdhan Ÿà azanOffset ŸÖŸÜ iqamaInfo
        let cal = Calendar.current, now = Date()
        guard let parsed = parser.date(from: timeString) else { return nil }
        var comps = cal.dateComponents([.hour, .minute], from: parsed)
        comps.year  = cal.component(.year,  from: now)
        comps.month = cal.component(.month, from: now)
        comps.day   = cal.component(.day,   from: now)
        guard let rawAdhan = cal.date(from: comps) else { return nil }

        let azanOffset: Int
        switch prayer {
        case "ÿßŸÑŸÅÿ¨ÿ±":   azanOffset = azanFajrOffset
        case "ÿßŸÑÿ∏Ÿáÿ±":   azanOffset = azanDhuhrOffset
        case "ÿßŸÑÿπÿµÿ±":   azanOffset = azanAsrOffset
        case "ÿßŸÑŸÖÿ∫ÿ±ÿ®":  azanOffset = azanMaghribOffset
        case "ÿßŸÑÿπÿ¥ÿßÿ°":  azanOffset = azanIshaOffset
        default:        azanOffset = 0
        }
        let adhanDate = cal.date(byAdding: .minute, value: azanOffset, to: rawAdhan)!

        return Int(adhanDate.timeIntervalSince(now))
    }

    
    private func requestNotificationPermission() {
        UNUserNotificationCenter.current()
            .requestAuthorization(options: [.alert, .sound, .badge]) { _, _ in }
    }
    

    
    // ÿØÿßÿÆŸÑ ContentView:
// ÿØÿßÿÆŸÑ ContentView ŸÑÿØŸäŸÉ already:

// ŸÇŸÖ ÿ®ÿ™ÿπÿØŸäŸÑ ÿßŸÑÿØÿßŸÑÿ© ŸÑÿ™ÿ≥ÿ™ÿÆÿØŸÖ selectedLanguage:
private func iqamaInfo(for timeString: String, prayer: String) -> (label: String, color: Color)? {
    let cal = Calendar.current
    let now = Date()

    // 1. ÿ≠ŸàŸëŸÑ ÿßŸÑŸÜÿµ ÿßŸÑÿ£ÿµŸÑŸä ŸÑŸÄ Date
    guard let parsed = parser.date(from: timeString) else { return nil }
    var comps = cal.dateComponents([.hour, .minute], from: parsed)
    comps.year  = cal.component(.year,  from: now)
    comps.month = cal.component(.month, from: now)
    comps.day   = cal.component(.day,   from: now)
    guard let adhanBase = cal.date(from: comps) else { return nil }

    // 2. ÿ≠ÿ≥ÿßÿ® ŸàŸÇÿ™ ÿßŸÑÿ£ÿ∞ÿßŸÜ ŸÖÿπ offset
    let azanOffset: Int
    switch prayer {
    case "ÿßŸÑŸÅÿ¨ÿ±":   azanOffset = azanFajrOffset
    case "ÿßŸÑÿ∏Ÿáÿ±":   azanOffset = azanDhuhrOffset
    case "ÿßŸÑÿπÿµÿ±":   azanOffset = azanAsrOffset
    case "ÿßŸÑŸÖÿ∫ÿ±ÿ®":  azanOffset = azanMaghribOffset
    case "ÿßŸÑÿπÿ¥ÿßÿ°":  azanOffset = azanIshaOffset
    default:        azanOffset = 0
    }
    let adhanDate = cal.date(byAdding: .minute, value: azanOffset, to: adhanBase)!

    // 3. ÿ≠ÿ≥ÿßÿ® ŸàŸÇÿ™ ÿßŸÑÿ•ŸÇÿßŸÖÿ© ŸÖÿπ offset
    let iqamaOffset: Int
    switch prayer {
    case "ÿßŸÑŸÅÿ¨ÿ±":   iqamaOffset = iqamaFajrOffset
    case "ÿßŸÑÿ∏Ÿáÿ±":   iqamaOffset = iqamaDhuhrOffset
    case "ÿßŸÑÿπÿµÿ±":   iqamaOffset = iqamaAsrOffset
    case "ÿßŸÑŸÖÿ∫ÿ±ÿ®":  iqamaOffset = iqamaMaghribOffset
    case "ÿßŸÑÿπÿ¥ÿßÿ°":  iqamaOffset = iqamaIshaOffset
    default:        iqamaOffset = 20
    }
    let iqamaDate = cal.date(byAdding: .minute, value: iqamaOffset, to: adhanDate)!

    // 4. ÿπÿ±ÿ∂ ŸÖÿß ŸÇÿ®ŸÑ ÿßŸÑÿ•ŸÇÿßŸÖÿ© ÿ£Ÿà ÿ®ÿπÿØŸáÿß ÿ≠ÿ™Ÿâ 30 ÿØŸÇŸäŸÇÿ©
    guard now >= adhanDate else { return nil }                        
    let windowEnd = iqamaDate.addingTimeInterval(30 * 60)
    guard now <= windowEnd else { return nil }

    let diff = iqamaDate.timeIntervalSince(now)                       
    let absSec = Int(abs(diff))
    let m = absSec / 60, s = absSec % 60
    let tp = String(format: "%02d:%02d", m, s)

    // ÿßÿ≥ÿ™ÿÆÿØŸÖ selectedLanguage ŸÑŸÑÿßÿÆÿ™Ÿäÿßÿ± ÿ®ŸäŸÜ ÿßŸÑÿπÿ±ÿ®Ÿä ŸàÿßŸÑÿ•ŸÜÿ¨ŸÑŸäÿ≤Ÿä
    if diff >= 0 {
        let label = (selectedLanguage == "ar")
            ? "ÿßŸÑÿ•ŸÇÿßŸÖÿ© ÿ®ÿπÿØ \(tp)"
            : "Iqama in \(tp)"
        return (label, .green)
    } else {
        let label = (selectedLanguage == "ar")
            ? "ŸÖÿ™ÿ£ÿÆÿ± ÿπŸÜ ÿßŸÑÿ•ŸÇÿßŸÖÿ© \(tp)"
            : "Late for Iqama by \(tp)"
        return (label, .red)
    }
}



//ŸáŸÜÿß ÿßŸÇÿßŸÖŸá
    
    // ÿØÿßÿÆŸÑ ContentView:
    private func schedulePrayerNotifications(_ timings: Timings) {
        let center = UNUserNotificationCenter.current()
        center.removeAllPendingNotificationRequests()
        
        // ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑÿ¥ÿ±ŸàŸÇ ÿ•ŸÑŸâ ŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿµŸÑŸàÿßÿ™
        let prayers = [
            ("ÿßŸÑŸÅÿ¨ÿ±",   timings.fajr),
            ("ÿßŸÑÿ¥ÿ±ŸàŸÇ",  timings.sunrise),
            ("ÿßŸÑÿ∏Ÿáÿ±",   timings.dhuhr),
            ("ÿßŸÑÿπÿµÿ±",   timings.asr),
            ("ÿßŸÑŸÖÿ∫ÿ±ÿ®",  timings.maghrib),
            ("ÿßŸÑÿπÿ¥ÿßÿ°",  timings.isha)
        ]
        
        for (name, timeString) in prayers {
            // ‚Üê Ÿáÿ∞ÿß ÿßŸÑÿ≥ÿ∑ÿ± ŸäÿÆÿ∑Ÿä ÿ¨ÿØŸàŸÑÿ© ÿ•ÿ¥ÿπÿßÿ± ÿßŸÑÿ¥ÿ±ŸàŸÇ ÿ•ÿ∞ÿß ŸÉÿßŸÜ ŸÖŸÉÿ™ŸàŸÖÿßŸã
            if name == "ÿßŸÑÿ¥ÿ±ŸàŸÇ" && muteNotifSunrise {
                continue
            }
            
            // ÿ™ŸÜÿ∏ŸäŸÅ ÿßŸÑÿ≥ŸÑÿ≥ŸÑÿ© Ÿàÿ™ÿ≠ŸàŸäŸÑŸáÿß ÿ•ŸÑŸâ Date
            let clean = timeString
                .trimmingCharacters(in: .whitespacesAndNewlines)
                .components(separatedBy: .whitespaces).first ?? timeString
            guard let date = parser.date(from: clean) else { continue }
            
            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ÿßŸÑŸÉŸàÿØ ÿßŸÑÿ¨ÿØŸäÿØ ŸÑŸÑÿ™ÿπŸàŸäÿ∂ ÿ®ŸÄ azanOffset ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            // 1. ŸÜÿ®ŸÜŸä ÿ™ÿßÿ±ŸäÿÆ ÿßŸÑŸäŸàŸÖ ÿπŸÜÿØ ŸàŸÇÿ™ ÿßŸÑÿµŸÑÿßÿ©
            let baseDate = Calendar.current.date(
                bySettingHour:   Calendar.current.component(.hour,   from: date),
                minute:          Calendar.current.component(.minute, from: date),
                second:          0,
                of:               Date()
            )!
            // 2. ŸÜÿÆÿ™ÿßÿ± ÿßŸÑŸÄ offset ÿßŸÑŸÖŸÜÿßÿ≥ÿ® ŸÑŸÉŸÑ ÿµŸÑÿßÿ©
            let offsetMinutes: Int
            switch name {
            case "ÿßŸÑŸÅÿ¨ÿ±":   offsetMinutes = azanFajrOffset
            case "ÿßŸÑÿ¥ÿ±ŸàŸÇ":  offsetMinutes = azanSunriseOffset
            case "ÿßŸÑÿ∏Ÿáÿ±":   offsetMinutes = azanDhuhrOffset
            case "ÿßŸÑÿπÿµÿ±":   offsetMinutes = azanAsrOffset
            case "ÿßŸÑŸÖÿ∫ÿ±ÿ®":  offsetMinutes = azanMaghribOffset
            case "ÿßŸÑÿπÿ¥ÿßÿ°":  offsetMinutes = azanIshaOffset
            default:        offsetMinutes = 0
            }
            // 3. ŸÜÿ∂ŸäŸÅ/ŸÜÿ∑ÿ±ÿ≠ ÿßŸÑŸÄ offset
            let fireDate = Calendar.current.date(
                byAdding: .minute,
                value: offsetMinutes,
                to: baseDate
            )!
            // 4. ŸÜÿ≠ŸàŸÑ ÿßŸÑÿ™ÿßÿ±ŸäÿÆ ÿßŸÑŸÖÿπŸàŸëŸéÿ∂ ÿ•ŸÑŸâ ŸÖŸÉŸàŸÜÿßÿ™ ÿ≥ÿßÿπÿ© ŸàÿØŸÇŸäŸÇÿ©
            let comps = Calendar.current.dateComponents([.hour, .minute], from: fireDate)
            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            
            // ÿ•ÿπÿØÿßÿØ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±
            let content = UNMutableNotificationContent()
            if name == "ÿßŸÑÿ¥ÿ±ŸàŸÇ" {
                content.title = "ÿ¥ÿ±ŸàŸÇ ÿßŸÑÿ¥ŸÖÿ≥"
                content.body  = "ÿ≠ÿßŸÜ ŸàŸÇÿ™ ÿ¥ÿ±ŸàŸÇ ÿßŸÑÿ¥ŸÖÿ≥"
                content.sound = nil  // ÿ®ÿØŸàŸÜ ÿµŸàÿ™
            } else {
                // ÿ∂ÿ®ÿ∑ ŸÉÿ™ŸÖ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ŸàÿßŸÑÿ£ÿ∞ÿßŸÜ ŸÑŸÑÿµŸÑÿßÿ©
                let isMuteNotif: Bool
                let isMuteAzan:  Bool
                switch name {
                case "ÿßŸÑŸÅÿ¨ÿ±":
                    isMuteNotif = muteNotifFajr;    isMuteAzan = muteAzanFajr
                case "ÿßŸÑÿ∏Ÿáÿ±":
                    isMuteNotif = muteNotifDhuhr;   isMuteAzan = muteAzanDhuhr
                case "ÿßŸÑÿπÿµÿ±":
                    isMuteNotif = muteNotifAsr;     isMuteAzan = muteAzanAsr
                case "ÿßŸÑŸÖÿ∫ÿ±ÿ®":
                    isMuteNotif = muteNotifMaghrib; isMuteAzan = muteAzanMaghrib
                case "ÿßŸÑÿπÿ¥ÿßÿ°":
                    isMuteNotif = muteNotifIsha;    isMuteAzan = muteAzanIsha
                default:
                    isMuteNotif = false; isMuteAzan = false
                }
                guard !isMuteNotif else { continue }
                
                content.title = "ÿ£ÿ∞ÿßŸÜ \(name)"
                content.body  = "ÿ≠ÿßŸÜ ŸàŸÇÿ™ ÿ£ÿ∞ÿßŸÜ \(name)"
                content.sound = isMuteAzan
                    ? nil
                    : UNNotificationSound(named: .init("azan.m4a"))
            }
            
            // ÿ¨ÿØŸàŸÑÿ© ÿßŸÑÿ™ŸÉÿ±ÿßÿ± ÿßŸÑŸäŸàŸÖŸä ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑŸÖŸÉŸàŸÜÿßÿ™ ÿ®ÿπÿØ offset
            var triggerComps = DateComponents()
            triggerComps.hour   = comps.hour
            triggerComps.minute = comps.minute
            let trigger = UNCalendarNotificationTrigger(dateMatching: triggerComps, repeats: true)
            
            // identifier ŸÖÿÆÿ™ŸÑŸÅ ŸÑŸÑÿ¥ÿ±ŸàŸÇ
            let identifier = (name == "ÿßŸÑÿ¥ÿ±ŸàŸÇ") ? "sunrise" : "azan_\(name)"
            let req = UNNotificationRequest(identifier: identifier, content: content, trigger: trigger)
            
            center.add(req) { error in
                if let e = error {
                    print("Failed to add \(name):", e)
                }
            }
        }
    }

    private func scheduleDhikrNotifications(_ timings: Timings) {
        let center = UNUserNotificationCenter.current()
        let prayers = [
            ("ÿßŸÑŸÅÿ¨ÿ±",   timings.fajr),
            ("ÿßŸÑÿ∏Ÿáÿ±",   timings.dhuhr),
            ("ÿßŸÑÿπÿµÿ±",   timings.asr),
            ("ÿßŸÑŸÖÿ∫ÿ±ÿ®",  timings.maghrib),
            ("ÿßŸÑÿπÿ¥ÿßÿ°",  timings.isha)
        ]

        // ÿ•ÿ≤ÿßŸÑÿ© ÿ£Ÿä ÿ¨ÿØÿßŸàŸÑ ÿ≥ÿßÿ®ŸÇÿ©
        let ids = prayers.map { "dhikr_\($0.0)" }
        center.removePendingNotificationRequests(withIdentifiers: ids)

        let day = Calendar.current.component(.day, from: Date())
        let cal = Calendar.current

        for (name, timeStr) in prayers {
            // 1. ÿ≠ŸàŸëŸÑ ŸÜÿµ ÿßŸÑŸàŸÇÿ™ ÿ•ŸÑŸâ Date ŸÅŸä ÿßŸÑŸäŸàŸÖ ÿßŸÑÿ≠ÿßŸÑŸä
            let clean = timeStr.trimmingCharacters(in: .whitespacesAndNewlines).components(separatedBy: .whitespaces).first ?? timeStr
            guard let parsed = parser.date(from: clean) else { continue }
            var comps = cal.dateComponents([.hour, .minute], from: parsed)
            comps.year  = cal.component(.year,  from: Date())
            comps.month = cal.component(.month, from: Date())
            comps.day   = cal.component(.day,   from: Date())
            guard let rawAdhan = cal.date(from: comps) else { continue }

            // 2. ÿ¨Ÿäÿ® azanOffset ŸÖŸÜ ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™
            let azanOffset: Int
            switch name {
            case "ÿßŸÑŸÅÿ¨ÿ±":   azanOffset = azanFajrOffset
            case "ÿßŸÑÿ∏Ÿáÿ±":   azanOffset = azanDhuhrOffset
            case "ÿßŸÑÿπÿµÿ±":   azanOffset = azanAsrOffset
            case "ÿßŸÑŸÖÿ∫ÿ±ÿ®":  azanOffset = azanMaghribOffset
            case "ÿßŸÑÿπÿ¥ÿßÿ°":  azanOffset = azanIshaOffset
            default:        azanOffset = 0
            }
            let adhanDate = cal.date(byAdding: .minute, value: azanOffset, to: rawAdhan)!

            // 3. ÿ≠ÿØŸëÿØ offset ÿßŸÑÿ£ÿ∞ŸÉÿßÿ± ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ÿßŸÑÿµŸÑÿßÿ©
            let dhikrOffset: Int
            switch name {
            case "ÿßŸÑŸÅÿ¨ÿ±":
                dhikrOffset = 30    // ÿ®ÿπÿØ ÿßŸÑÿ¢ÿ∞ÿßŸÜ ÿ®ŸÄŸÄ30 ÿØŸÇŸäŸÇÿ©
            case "ÿßŸÑŸÖÿ∫ÿ±ÿ®":
                dhikrOffset = -30   // ŸÇÿ®ŸÑ ÿßŸÑÿ¢ÿ∞ÿßŸÜ ÿ®ŸÄŸÄ30 ÿØŸÇŸäŸÇÿ©
            default:
                dhikrOffset = -20   // ŸÇÿ®ŸÑ ÿ®ŸÇŸäÿ© ÿßŸÑÿµŸÑŸàÿßÿ™ ÿ®ŸÄŸÄ20 ÿØŸÇŸäŸÇÿ©
            }

            // 4. ÿßÿ≠ÿ≥ÿ® ŸÖŸàÿπÿØ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±
            guard let fireDate = cal.date(byAdding: .minute, value: dhikrOffset, to: adhanDate) else { continue }
            let compsFire = cal.dateComponents([.hour, .minute], from: fireDate)

            // 5. ÿ¨ŸáŸëÿ≤ ŸÖÿ≠ÿ™ŸàŸâ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±
            let content = UNMutableNotificationContent()
            content.title = "ÿ£ÿ∞ŸÉÿßÿ±"
            content.sound = .default

            // ÿßÿÆÿ™Ÿäÿßÿ± ŸÜÿµ ÿßŸÑÿ∞ŸÉÿ±
            let dhikrOptions: [String: [String]] = [
                "ÿßŸÑŸÅÿ¨ÿ±":  ["ÿ≠ÿßŸÜ ŸàŸÇÿ™ ŸÇÿ±ÿßÿ°ÿ™ŸÉ ŸÑÿ£ÿ∞ŸÉÿßÿ± ÿßŸÑÿµÿ®ÿßÿ≠"],
                "ÿßŸÑÿ∏Ÿáÿ±":  ["ÿ≥ÿ®ÿ≠ÿßŸÜ ÿßŸÑŸÑŸá", "ŸàŸÇŸÑ ÿ±ÿ® ÿßÿ∫ŸÅÿ± Ÿàÿßÿ±ÿ≠ŸÖ Ÿàÿ£ŸÜÿ™ ÿÆŸäÿ± ÿßŸÑÿ±ÿßÿ≠ŸÖŸäŸÜ", "ÿßŸÑÿ≠ŸÖÿØŸÑŸÑŸá"],
                "ÿßŸÑÿπÿµÿ±":  ["ŸÑÿß ÿ•ŸÑŸá ÿ•ŸÑÿß ÿßŸÑŸÑŸá", "ÿßŸÑŸÑŸëŸéŸáŸèŸÖŸëŸé ÿµŸéŸÑŸëŸê ŸàŸéÿ≥ŸéŸÑŸëŸêŸÖŸí ÿπŸéŸÑŸéŸâ ŸÜŸéÿ®ŸêŸäŸëŸêŸÜŸéÿß ŸÖŸèÿ≠ŸéŸÖŸëŸéÿØŸç", "ÿ≥ÿ®ÿ≠ÿßŸÜ ÿßŸÑŸÑŸá Ÿàÿ®ÿ≠ŸÖÿØŸá"],
                "ÿßŸÑŸÖÿ∫ÿ±ÿ®": ["ÿ≠ÿßŸÜ ŸàŸÇÿ™ ŸÇÿ±ÿßÿ°ÿ™ŸÉ ŸÑÿ£ÿ∞ŸÉÿßÿ± ÿßŸÑŸÖÿ≥ÿßÿ°"],
                "ÿßŸÑÿπÿ¥ÿßÿ°": ["ÿ£ÿπŸàÿ∞ ÿ®ŸÉŸÑŸÖÿßÿ™ ÿßŸÑŸÑŸá ÿßŸÑÿ™ÿßŸÖÿßÿ™ ŸÖŸÜ ÿ¥ÿ± ŸÖÿß ÿÆŸÑŸÇ", "ÿ≥ÿ®ÿ≠ÿßŸÜ ÿßŸÑŸÑŸá Ÿàÿ®ÿ≠ŸÖÿØŸá", "ŸÑÿß ÿ≠ŸàŸÑ ŸàŸÑÿß ŸÇŸàÿ© ÿ•ŸÑÿß ÿ®ÿßŸÑŸÑŸá"]
            ]
            if let arr = dhikrOptions[name] {
                if name == "ÿßŸÑŸÅÿ¨ÿ±" || name == "ÿßŸÑŸÖÿ∫ÿ±ÿ®" {
                    content.body = arr.first!
                } else {
                    // ÿØŸàŸëÿ± ÿ∞ŸÉÿ± ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ ÿßŸÑŸäŸàŸÖ Ÿàÿ™ÿ±ÿ™Ÿäÿ® ÿßŸÑÿµŸÑÿßÿ©
                    let offsets = ["ÿßŸÑŸÅÿ¨ÿ±":0,"ÿßŸÑÿ∏Ÿáÿ±":1,"ÿßŸÑÿπÿµÿ±":2,"ÿßŸÑŸÖÿ∫ÿ±ÿ®":3,"ÿßŸÑÿπÿ¥ÿßÿ°":4]
                    let idx = ((day - 1) + (offsets[name] ?? 0)) % arr.count
                    content.body = arr[idx]
                }
            }



            // 6. ÿßÿ¨ÿØŸàŸÑ ÿßŸÑÿ•ÿ¥ÿπÿßÿ±
            var triggerComps = DateComponents()
            triggerComps.hour   = compsFire.hour
            triggerComps.minute = compsFire.minute
            let trigger = UNCalendarNotificationTrigger(dateMatching: triggerComps, repeats: true)
            let req = UNNotificationRequest(identifier: "dhikr_\(name)", content: content, trigger: trigger)
            center.add(req) { if let e = $0 { print("ÿÆÿ∑ÿ£ ÿ¨ÿØŸàŸÑÿ© ÿ∞ŸÉÿ± \(name):", e) } }
        }
    }

    
    // MARK: ‚Äì View Body
    var body: some View {
        NavigationStack {
            
            ZStack {
                                LinearGradient(gradient: Gradient(colors: [
        Color(red: 0.12, green: 0.25, blue: 0.33),    // ÿ£ÿ≤ÿ±ŸÇ ÿ∫ÿßŸÖŸÇ ŸÑŸäŸÑŸä
        Color(red: 0.20, green: 0.25, blue: 0.33),       // ÿ®ŸÜŸÅÿ≥ÿ¨Ÿä ÿ∫ÿßŸÖŸÇ ŸÑŸäŸÑŸä
        Color(red: 0.1, green: 0.15, blue: 0.3),      // ÿ£ÿ≤ÿ±ŸÇ ÿ∫ÿßŸÖŸÇ ŸÑŸäŸÑŸä ÿ¢ÿÆÿ±
        Color(red: 0.15, green: 0.05, blue: 0.25),     // ÿ£ÿÆÿ∂ÿ± ÿ∫ÿßŸÖŸÇ ŸÑŸäŸÑŸä
        Color(red: 0.12, green: 0.25, blue: 0.33),    // ÿ£ÿ≤ÿ±ŸÇ ÿ∫ÿßŸÖŸÇ ŸÑŸäŸÑŸä
    
                ]), startPoint: .top, endPoint: .bottom)
                .ignoresSafeArea()
                
                VStack(spacing:20) {
                    // Top Bar
                    HStack {
                        Button { showSettings.toggle() } label: {
                            Image(systemName: "gearshape.fill")
                                .font(.system(size:20))
                                .foregroundColor(.white)
                                .padding(.leading,28)
                        }
                        Spacer()
                    }
                    .padding(.top,30)
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    // Compass & Location & Date
                    if let loc = locationManager.location {






                        VStack(spacing: 8) {

// ‚Ä¶




    // ÿßŸÑŸÜÿµŸàÿµ ÿ™ÿ™ÿ∫Ÿäÿ± ÿ™ÿ±ÿ™Ÿäÿ®Ÿáÿß ŸàŸÅŸÇ ÿßŸÑŸÑÿ∫ÿ©
HStack(alignment: .center, spacing: 14) {
    // ‚Äî‚Äî‚Äî ÿßŸÑÿ®ŸàÿµŸÑÿ© ÿπŸÑŸâ ÿßŸÑŸäÿ≥ÿßÿ± ‚Äî‚Äî‚Äî
    EnhancedCompassView(
        heading: locationManager.heading?.trueHeading,
        bearing: qiblaBearing(from: loc)
    )
    .frame(width: 60, height: 60)
    .offset(x: 20)

    Spacer()

    // ‚Äî‚Äî‚Äî ÿßŸÑŸÜÿµŸàÿµ ÿπŸÑŸâ ÿßŸÑŸäŸÖŸäŸÜ ‚Äî‚Äî‚Äî
  VStack(alignment: .leading, spacing: 4) {
    // ÿßŸÑŸàŸÇÿ™
    HStack {
        if isArabic {
            Text(localizedTime)
                .foregroundColor(.green)
            Spacer()
            Text("ÿßŸÑŸàŸÇÿ™:")
                .foregroundColor(.white)
        } else {
            Text("Time:")
                .foregroundColor(.white)
            Spacer()
            Text(localizedTime)
                .foregroundColor(.green)
        }
    }
    Divider().background(Color.white.opacity(0.3))

    // ÿßŸÑŸäŸàŸÖ
    HStack {
        if isArabic {
            Text(localizedWeekday)
                .foregroundColor(.green)
            Spacer()
            Text("ÿßŸÑŸäŸàŸÖ:")
                .foregroundColor(.white)
        } else {
            Text("Day:")
                .foregroundColor(.white)
            Spacer()
            Text(localizedWeekday)
                .foregroundColor(.green)
        }
    }
    Divider().background(Color.white.opacity(0.3))

    // ÿßŸÑÿ™ÿßÿ±ŸäÿÆ ÿßŸÑŸÖŸäŸÑÿßÿØŸä
    HStack {
        if isArabic {
            Text(localizedDate)
                .foregroundColor(.green)
            Spacer()
            Text("ÿßŸÑÿ™ÿßÿ±ŸäÿÆ:")
                .foregroundColor(.white)
        } else {
            Text("Date:")
                .foregroundColor(.white)
            Spacer()
            Text(localizedDate)
                .foregroundColor(.green)
        }
    }
    Divider().background(Color.white.opacity(0.3))

    // ÿßŸÑÿ™ÿßÿ±ŸäÿÆ ÿßŸÑŸáÿ¨ÿ±Ÿä
    HStack {
        if isArabic {
            Text(localizedHijri)
                .foregroundColor(.green)
            Spacer()
            Text("ÿßŸÑÿ™ÿßÿ±ŸäÿÆ ÿßŸÑŸáÿ¨ÿ±Ÿä:")
                .foregroundColor(.white)
        } else {
            Text("Hijri Date:")
                .foregroundColor(.white)
            Spacer()
            Text(localizedHijri)
                .foregroundColor(.green)
        }
    }
    Divider().background(Color.white.opacity(0.3))

    // ÿßŸÑŸÖÿØŸäŸÜÿ© ŸàÿßŸÑÿ®ŸÑÿØ
    HStack {
        if isArabic {
            Text(localizedLocation)
                .foregroundColor(.green)
            Spacer()
            Text("ÿßŸÑÿØŸàŸÑÿ©:")
                .foregroundColor(.white)
        } else {
            Text("Location:")
                .foregroundColor(.white)
            Spacer()
            Text(localizedLocation)
                .foregroundColor(.green)
        }
    }
}
.font(.system(size: 14, weight: .medium, design: .rounded))
.frame(width: 210, alignment: .leading)

}
.padding(13)
.background(Color.black.opacity(0.3))
.cornerRadius(8)
.padding(.horizontal, 25)


                            
                        }
                        
                    }
                    
                    
                    
                  
   // --- ŸÅŸä ContentView.swift ÿØÿßÿÆŸÑ ÿßŸÑŸÄ body ÿßÿ≥ÿ™ÿ®ÿØŸÑ ÿßŸÑŸÇÿ≥ŸÖ ÿßŸÑŸÇÿØŸäŸÖ ÿ®Ÿáÿ∞ÿß ÿßŸÑŸÇÿ≥ŸÖ: ---
                    if locationManager.location == nil {
                        switch locationManager.authStatus {
                        case .denied, .restricted:
                            VStack(spacing: 16) {
                                Text("Ÿäÿ¨ÿ® ÿ™ŸÅÿπŸäŸÑ ÿßŸÑŸÖŸàŸÇÿπ ŸÑÿ™ÿ™ŸÖŸÉŸÜ ŸÖŸÜ ÿ≠ÿ≥ÿßÿ® ŸÖŸàÿßŸÇŸäÿ™ ÿßŸÑÿµŸÑÿßÿ©:\nÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™ ‚Üê ÿßŸÑÿÆÿµŸàÿµŸäÿ© ‚Üê ÿÆÿØŸÖÿßÿ™ ÿßŸÑŸÖŸàŸÇÿπ ‚Üê ÿ™ÿ∑ÿ®ŸäŸÇ ‚Üê ÿ≥ŸÖÿßÿ≠ ÿßŸÑŸàÿµŸàŸÑ ÿØÿßÿ¶ŸÖÿßŸã")
                                    .multilineTextAlignment(.center)
                                    .foregroundColor(.white)
                                Button("ŸÅÿ™ÿ≠ ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ") {
                                    if let url = URL(string: UIApplication.openSettingsURLString) {
                                        UIApplication.shared.open(url)
                                    }
                                }
                                .padding(.horizontal, 20)
                                .padding(.vertical, 10)
                                .background(Color.green)
                                .foregroundColor(.white)
                                .cornerRadius(8)
                            }
                            .padding()
                        default:
                            ProgressView("ÿ¨ÿßÿ±Ÿä ÿ≠ÿ≥ÿßÿ® ŸÖŸàÿßŸÇŸäÿ™ ÿßŸÑÿµŸÑÿßÿ©‚Ä¶")
                                .foregroundColor(.white)
                        }
                    }
                    else if isLoading {
                        ProgressView("ÿ¨ÿßÿ±Ÿä ÿ≠ÿ≥ÿßÿ® ŸÖŸàÿßŸÇŸäÿ™ ÿßŸÑÿµŸÑÿßÿ©‚Ä¶")
                            .foregroundColor(.white)
                    }
                    else if let t = prayerTimes {
                        VStack(spacing: 8) {
                            HStack {
                                Button { showEditIqama.toggle() } label: {
                                    HStack(spacing: 4) {
                                        Image(systemName: "switch.2")
                                        Text("ÿ™ÿ≠ÿ±Ÿäÿ±")
                                    }
                                    .foregroundColor(.green)
                                }
                                Spacer()
                            }
                            .padding(.leading, 27)
                            // ‚Ä¶ ÿ®ŸÇŸäÿ© ÿπÿ±ÿ∂ ÿ£ŸàŸÇÿßÿ™ ÿßŸÑÿµŸÑÿßÿ© ‚Ä¶
                            
                        
                            
                            
                            
                            
                            // ‚Ä¶ ÿ®ŸÇŸäÿ© ŸÖÿ≠ÿ™ŸàŸâ VStack ÿßŸÑÿÆÿßÿµ ÿ®ÿπÿ±ÿ∂ ÿ£ŸàŸÇÿßÿ™ ÿßŸÑÿµŸÑÿßÿ© ‚Ä¶
                            
                            
                            // ÿ®ŸÇŸäÿ© ÿßŸÑŸÄ VStack ‚Ä¶
                            
                            //ŸáŸÜÿß ÿ¨ÿØŸàŸÑ
                            


VStack(spacing: 8) {
    ForEach(Array([
        (isArabic ? "ÿßŸÑŸÅÿ¨ÿ±" : "Fajr",       t.fajr),
        (isArabic ? "ÿßŸÑÿ¥ÿ±ŸàŸÇ" : "Sunrise",    t.sunrise),
        (isArabic ? "ÿßŸÑÿ∏Ÿáÿ±" : "Dhuhr",      t.dhuhr),
        (isArabic ? "ÿßŸÑÿπÿµÿ±" : "Asr",        t.asr),
        (isArabic ? "ÿßŸÑŸÖÿ∫ÿ±ÿ®" : "Maghrib",   t.maghrib),
        (isArabic ? "ÿßŸÑÿπÿ¥ÿßÿ°" : "Isha",      t.isha)
    ].enumerated()), id: \.0) { idx, item in
        HStack(alignment: .top, spacing: 12) {
            if isArabic {
                // ÿ£ÿ≤ÿ±ÿßÿ± ÿßŸÑÿµŸàÿ™ ŸàÿßŸÑÿ•ÿ¥ÿπÿßÿ± ŸàÿßŸÑŸàŸÇÿ™ ÿ®ÿßŸÑÿπÿ±ÿ®Ÿä
                Button {
                    toggleAzanMute(for: item.0)
                    if soundEnabled  { SoundPlayer.shared.play("click") }
                    if hapticEnabled { UIImpactFeedbackGenerator(style: .light).impactOccurred() }
                } label: {
                    Image(systemName: isAzanMuted(for: item.0)
                          ? "speaker.slash.fill"
                          : "speaker.wave.2.fill")
                    .foregroundColor(isAzanMuted(for: item.0) ? .red : .white)
                }

                Divider()
                    .frame(width: 1, height: 20)
                    .background(Color.white.opacity(0.3))

                Button {
                    toggleNotifMute(for: item.0)
                    if soundEnabled  { SoundPlayer.shared.play("click") }
                    if hapticEnabled { UIImpactFeedbackGenerator(style: .light).impactOccurred() }
                } label: {
                    Image(systemName: isNotifMuted(for: item.0)
                          ? "bell.slash.fill"
                          : "bell.fill")
                    .foregroundColor(isNotifMuted(for: item.0) ? .red : .white)
                }

                Divider()
                    .frame(width: 1, height: 20)
                    .background(Color.white.opacity(0.3))

                VStack(alignment: .leading, spacing: 4) {
                    Text(adjustedAzanTime(item.1, for: item.0))
                        .font(.system(.body, design: .monospaced))
                        .foregroundColor(.white)

                    if item.0 != "ÿßŸÑÿ¥ÿ±ŸàŸÇ" {
                        if let secs = countdownSeconds(for: item.1, prayer: item.0) {
                            if secs > 0 && secs <= 80 * 60 {
                                let hours = secs / 3600
                                let minutes = (secs % 3600) / 60
                                let seconds = secs % 60
                                let countdown = String(format: "%02d:%02d:%02d", hours, minutes, seconds)

                                Text("ÿ£ÿ∞ÿßŸÜ \(item.0) ÿ®ÿπÿØ \(countdown)")
                                    .font(.caption.monospacedDigit())
                                    .foregroundColor(.yellow)
                            }
                        }
                        if let info = iqamaInfo(for: item.1, prayer: item.0) {
                            Text(info.label)
                                .font(.caption.monospacedDigit())
                                .foregroundColor(info.color)
                        }
                    }
                }

                Spacer()

                HStack(spacing: 4) {
                    Text(item.0)
                        .foregroundColor(.white)
                    if nextPrayerIndex == idx && item.0 != "ÿßŸÑÿ¥ÿ±ŸàŸÇ" {
                        Image(systemName: "arrowtriangle.left.fill")
                            .foregroundColor(.white)
                            .opacity(0.3)
                            .padding(.trailing, -21)
                    }
                }
                .frame(width: 80, alignment: .trailing)
            } else {
                HStack(spacing: 4) {
                    if nextPrayerIndex == idx && item.0 != "Sunrise" {
                        Image(systemName: "arrowtriangle.right.fill")
                            .foregroundColor(.white)
                            .opacity(0.3)
                            .padding(.leading, -21)
                    }
                    Text(item.0)
                        .foregroundColor(.white)
                }
                .frame(width: 80, alignment: .leading)

                Spacer()

                VStack(alignment: .trailing, spacing: 4) {
                    Text(adjustedAzanTime(item.1, for: item.0))
                        .font(.system(.body, design: .monospaced))
                        .foregroundColor(.white)

                    if item.0 != "Sunrise" {
                        if let secs = countdownSeconds(for: item.1, prayer: item.0) {
                            if secs > 0 && secs <= 80 * 60 {
                                let hours = secs / 3600
                                let minutes = (secs % 3600) / 60
                                let seconds = secs % 60
                                let countdown = String(format: "%02d:%02d:%02d", hours, minutes, seconds)

                                Text("\(item.0) Azan in \(countdown)")
                                    .font(.caption.monospacedDigit())
                                    .foregroundColor(.yellow)
                            }
                        }
                        if let info = iqamaInfo(for: item.1, prayer: item.0) {
                            Text(info.label)
                                .font(.caption.monospacedDigit())
                                .foregroundColor(info.color)
                        }
                    }
                }

                Divider()
                    .frame(width: 1, height: 20)
                    .background(Color.white.opacity(0.3))

                Button {
                    toggleNotifMute(for: item.0 == "Fajr" ? "ÿßŸÑŸÅÿ¨ÿ±" : 
                                  item.0 == "Sunrise" ? "ÿßŸÑÿ¥ÿ±ŸàŸÇ" :
                                  item.0 == "Dhuhr" ? "ÿßŸÑÿ∏Ÿáÿ±" :
                                  item.0 == "Asr" ? "ÿßŸÑÿπÿµÿ±" :
                                  item.0 == "Maghrib" ? "ÿßŸÑŸÖÿ∫ÿ±ÿ®" : "ÿßŸÑÿπÿ¥ÿßÿ°")
                    if soundEnabled  { SoundPlayer.shared.play("click") }
                    if hapticEnabled { UIImpactFeedbackGenerator(style: .light).impactOccurred() }
                } label: {
                    Image(systemName: isNotifMuted(for: item.0 == "Fajr" ? "ÿßŸÑŸÅÿ¨ÿ±" : 
                                                 item.0 == "Sunrise" ? "ÿßŸÑÿ¥ÿ±ŸàŸÇ" :
                                                 item.0 == "Dhuhr" ? "ÿßŸÑÿ∏Ÿáÿ±" :
                                                 item.0 == "Asr" ? "ÿßŸÑÿπÿµÿ±" :
                                                 item.0 == "Maghrib" ? "ÿßŸÑŸÖÿ∫ÿ±ÿ®" : "ÿßŸÑÿπÿ¥ÿßÿ°") ? "bell.slash.fill" : "bell.fill")
                        .foregroundColor(isNotifMuted(for: item.0 == "Fajr" ? "ÿßŸÑŸÅÿ¨ÿ±" : 
                                                    item.0 == "Sunrise" ? "ÿßŸÑÿ¥ÿ±ŸàŸÇ" :
                                                    item.0 == "Dhuhr" ? "ÿßŸÑÿ∏Ÿáÿ±" :
                                                    item.0 == "Asr" ? "ÿßŸÑÿπÿµÿ±" :
                                                    item.0 == "Maghrib" ? "ÿßŸÑŸÖÿ∫ÿ±ÿ®" : "ÿßŸÑÿπÿ¥ÿßÿ°") ? .red : .white)
                }

                Divider()
                    .frame(width: 1, height: 20)
                    .background(Color.white.opacity(0.3))

                Button {
                    toggleAzanMute(for: item.0 == "Fajr" ? "ÿßŸÑŸÅÿ¨ÿ±" : 
                                 item.0 == "Sunrise" ? "ÿßŸÑÿ¥ÿ±ŸàŸÇ" :
                                 item.0 == "Dhuhr" ? "ÿßŸÑÿ∏Ÿáÿ±" :
                                 item.0 == "Asr" ? "ÿßŸÑÿπÿµÿ±" :
                                 item.0 == "Maghrib" ? "ÿßŸÑŸÖÿ∫ÿ±ÿ®" : "ÿßŸÑÿπÿ¥ÿßÿ°")
                    if soundEnabled  { SoundPlayer.shared.play("click") }
                    if hapticEnabled { UIImpactFeedbackGenerator(style: .light).impactOccurred() }
                } label: {
                    Image(systemName: isAzanMuted(for: item.0 == "Fajr" ? "ÿßŸÑŸÅÿ¨ÿ±" : 
                                                item.0 == "Sunrise" ? "ÿßŸÑÿ¥ÿ±ŸàŸÇ" :
                                                item.0 == "Dhuhr" ? "ÿßŸÑÿ∏Ÿáÿ±" :
                                                item.0 == "Asr" ? "ÿßŸÑÿπÿµÿ±" :
                                                item.0 == "Maghrib" ? "ÿßŸÑŸÖÿ∫ÿ±ÿ®" : "ÿßŸÑÿπÿ¥ÿßÿ°") ? "speaker.slash.fill" : "speaker.wave.2.fill")
                        .foregroundColor(isAzanMuted(for: item.0 == "Fajr" ? "ÿßŸÑŸÅÿ¨ÿ±" : 
                                                   item.0 == "Sunrise" ? "ÿßŸÑÿ¥ÿ±ŸàŸÇ" :
                                                   item.0 == "Dhuhr" ? "ÿßŸÑÿ∏Ÿáÿ±" :
                                                   item.0 == "Asr" ? "ÿßŸÑÿπÿµÿ±" :
                                                   item.0 == "Maghrib" ? "ÿßŸÑŸÖÿ∫ÿ±ÿ®" : "ÿßŸÑÿπÿ¥ÿßÿ°") ? .red : .white)
                }
            }
        }

        if item.0 != (isArabic ? "ÿßŸÑÿπÿ¥ÿßÿ°" : "Isha") {
            Divider().background(Color.white.opacity(0.3))
        }
    }
}
.padding()
.background(Color.black.opacity(0.3))
.cornerRadius(15)
.padding(.horizontal, 25)

                        }
                    }
                    
                    
                    
                    // ‚Üì ÿ®ÿØŸÑ ScrollView+LazyVGrid ÿßŸÑŸÇÿØŸäŸÖ:
                    // ÿØÿßÿÆŸÑ ContentView‚Äôs bodyÿå ÿßÿ≥ÿ™ÿ®ÿØŸÑ ÿßŸÑŸÄ ScrollView ÿßŸÑŸÇÿØŸäŸÖ ÿ®Ÿáÿ∞ÿß ÿßŸÑŸÉŸàÿØ ÿßŸÑŸÉÿßŸÖŸÑ:
                    

ScrollView {
    // ‚Äî‚Äî‚Äî ÿßŸÑÿ£ÿ∞ŸÉÿßÿ± ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ© ‚Äî‚Äî‚Äî
    HStack(spacing: 14) {
        // ÿ£ÿ∞ŸÉÿßÿ± ÿßŸÑŸÖÿ≥ÿßÿ°
        NavigationLink(destination: DhikrDetailView(dhikrType: .evening)) {
            HStack(spacing: 12) {
                // ÿßŸÑÿ•ŸäŸÇŸàŸÜÿ© ÿπŸÑŸâ ÿßŸÑŸäÿ≥ÿßÿ±
Image("eveningIcon")
    .resizable()
    .scaledToFit()
    .frame(width: 50, height: 50)
    .background(Color.white.opacity(0.2))
    .clipShape(Circle())
    .overlay(
        Circle()
            .stroke(Color.gray, lineWidth: 2)
    )
    .padding(.leading, 8)

Text("ÿ£ÿ∞ŸÉÿßÿ± ÿßŸÑŸÖÿ≥ÿßÿ°")
    .font(.system(size: 15))
    .foregroundColor(.white)
    .padding(.leading, 8)

Spacer()
            }
            .padding(0)
            .frame(width: 180, height: 60)
            .background(Color.clear)
            .overlay(
                RoundedRectangle(cornerRadius: 14)
                    .strokeBorder(Color.slateGray, lineWidth: 2)
            )
        }
        
        // ÿ£ÿ∞ŸÉÿßÿ± ÿßŸÑÿµÿ®ÿßÿ≠
        NavigationLink(destination: DhikrDetailView(dhikrType: .morning)) {
            HStack(spacing: 12) {
                Image("morningIcon")
                    .resizable()
                    .scaledToFit()
                    .frame(width: 50, height: 50)
                    .background(Color.white.opacity(0.2))
    .clipShape(Circle())
    .overlay(
        Circle()
            .stroke(Color.gray, lineWidth: 2)
    )
    .padding(.leading, 8)

                Text("ÿ£ÿ∞ŸÉÿßÿ± ÿßŸÑÿµÿ®ÿßÿ≠")
                    .font(.system(size: 15))
                    .foregroundColor(.white)
.padding(.leading, 8)
                
                Spacer()
            }
            .padding(0)
            .frame(width: 180, height: 60)
            .background(Color.clear)
            .overlay(
                RoundedRectangle(cornerRadius: 14)
                    .strokeBorder(Color.slateGray, lineWidth: 2)
            )
        }
    }
    
    HStack(spacing: 14) {
        // ÿ£ÿ∞ŸÉÿßÿ± ÿßŸÑÿßÿ≥ÿ™ŸäŸÇÿßÿ∏
        NavigationLink(destination: DhikrDetailView(dhikrType: .awakening)) {
            HStack(spacing: 12) {
                Image("awakeningIcon")
                    .resizable()
                    .scaledToFit()
                    .frame(width: 50, height: 50)
                    .background(Color.white.opacity(0.2))
    .clipShape(Circle())
    .overlay(
        Circle()
            .stroke(Color.gray, lineWidth: 2)
    )
    .padding(.leading, 8)

                Text("ÿ£ÿ∞ŸÉÿßÿ± ÿßŸÑÿßÿ≥ÿ™ŸäŸÇÿßÿ∏")
                    .font(.system(size: 14.5))
                    .foregroundColor(.white)
.padding(.leading, 8)
                
                Spacer()
            }
            .padding(0)
            .frame(width: 180, height: 60)
            .background(Color.clear)
            .overlay(
                RoundedRectangle(cornerRadius: 14)
                    .strokeBorder(Color.slateGray, lineWidth: 2)
            )
        }
        
        // ÿ£ÿ∞ŸÉÿßÿ± ÿßŸÑŸÜŸàŸÖ
        NavigationLink(destination: DhikrDetailView(dhikrType: .sleep)) {
            HStack(spacing: 12) {
                Image("sleepIcon")
                    .resizable()
                    .scaledToFit()
                    .frame(width: 50, height: 50)
                    .background(Color.white.opacity(0.2))
    .clipShape(Circle())
    .overlay(
        Circle()
            .stroke(Color.gray, lineWidth: 2)
    )
    .padding(.leading, 8)

                Text("ÿ£ÿ∞ŸÉÿßÿ± ÿßŸÑŸÜŸàŸÖ")
                    .font(.system(size: 15))
                    .foregroundColor(.white)
.padding(.leading, 8)
                
                Spacer()
            }
            .padding(0)
            .frame(width: 180, height: 60)
            .background(Color.clear)
            .overlay(
                RoundedRectangle(cornerRadius: 14)
                    .strokeBorder(Color.slateGray, lineWidth: 2)
            )
        }
    }
    HStack(spacing: 14) {
        
        NavigationLink(destination: AlzakeerMenuView()) {
            HStack(spacing: 12) {
                Image("alzakeerIcon")
                    .resizable()
                    .scaledToFit()
                    .frame(width: 50, height: 50)
                    .background(Color.white.opacity(0.2))
    .clipShape(Circle())
    .overlay(
        Circle()
            .stroke(Color.gray, lineWidth: 2)
    )
    .padding(.leading, 8)
                
                Text("ÿ¨ŸÖŸäÿπ ÿßŸÑÿ£ŸÇÿ≥ÿßŸÖ")
                    .font(.system(size: 15))
                    .foregroundColor(.white)
                    .padding(.leading, 8)
                
                Spacer()
            }
            .padding(0)
            .frame(width: 180, height: 60)
            .background(Color.clear)
            .overlay(
                RoundedRectangle(cornerRadius: 14)
                    .strokeBorder(Color.slateGray, lineWidth: 2)
            )
        }
        

    }

}
.padding(.horizontal, 25)
.frame(maxHeight: .infinity)
.ignoresSafeArea(.keyboard, edges: .bottom)
    }


                .environment(\.layoutDirection, .leftToRight) // ‚Üê Ÿäÿ¨ÿπŸÑ ÿßŸÑÿßÿ™ÿ¨ÿßŸá ÿ•ŸÜÿ¨ŸÑŸäÿ≤Ÿä ŸÑŸÉŸÜ Ÿäÿ≠ÿßŸÅÿ∏ ÿπŸÑŸâ ÿßŸÑŸÜÿµ ÿßŸÑÿπÿ±ÿ®Ÿä
                
                
                
                .navigationBarHidden(true)
            }
            // ÿ£ŸàŸÑÿßŸã sheet ŸÑŸÑÿ•ÿπÿØÿßÿØÿßÿ™

            // ÿ´ŸÖ sheet ŸÑÿ™ÿ≠ÿ±Ÿäÿ± ÿßŸÑÿ•ŸÇÿßŸÖÿ©
// 2) ÿßÿ≥ÿ™ÿ®ÿØŸÑ ÿßŸÑŸÄ sheet ÿßŸÑÿ≠ÿßŸÑŸä ÿ®Ÿáÿ∞ÿß:


                                
                        
                        
                        
    // ‚Ä¶ ÿØÿßÿÆŸÑ ÿßŸÑŸÄ Form ‚Ä¶


// ŸÇÿ®ŸÑ ŸÉŸÑ ÿ¥Ÿäÿ° ÿ≠ÿØŸëŸêÿ´ ÿØÿßŸÑÿ© adjustedAzanTime ŸÑÿ™ÿ∂ŸäŸÅ_OFFSET_ ÿ•ŸÑŸâ ÿßŸÑŸàŸÇÿ™ ÿßŸÑÿ£ÿµŸÑŸä:


// ÿØÿßÿÆŸÑ ÿßŸÑŸÄ Sheet ÿßŸÑÿÆÿßÿµ ÿ®ÿ™ÿ≠ÿ±Ÿäÿ± ÿßŸÑÿ£ÿ∞ÿßŸÜÿå ÿßÿ≥ÿ™ÿ®ÿØŸÑ ÿßŸÑŸÇÿ≥ŸÖ ÿ®ŸÄ:

                                
              
            // ŸÅŸä ŸÜŸáÿßŸäÿ© ÿ™ÿπÿ±ŸäŸÅ ÿßŸÑŸÄ View ÿØÿßÿÆŸÑ ContentViewÿå ÿ®ÿπÿØ .preferredColorScheme(...)
// ÿØÿßÿÆŸÑ ÿßŸÑŸÄ View ÿ£Ÿà ÿßŸÑŸÄ ViewModifier ÿ≠Ÿäÿ´ ŸÑÿØŸäŸÉ ÿßŸÑŸÄ onAppear Ÿà onReceive
            .onAppear {
              requestNotificationPermission()
               
                               
                           
                        }
            .onReceive(locationManager.$location) { _ in
              isLoading = true
  PrayerTimesServiceOffline.shared.getPrayerTimes(date: Date()) { timings in
    DispatchQueue.main.async {
      prayerTimes = timings
      settingsTimings = timings
      schedulePrayerNotifications(timings)
      if notificationsEnabled {
        scheduleDhikrNotifications(timings)
      }
      isLoading = false
    }
  }
}
.onReceive(timer) { time in
  now = time
  let today = Calendar.current.startOfDay(for: time)
  if today != lastFetchedDay {
    lastFetchedDay = today
    isLoading = true
    PrayerTimesServiceOffline.shared.getPrayerTimes(date: time) { timings in
      DispatchQueue.main.async {
        prayerTimes = timings
        schedulePrayerNotifications(timings)
        if notificationsEnabled {
          scheduleDhikrNotifications(timings)
        }
        isLoading = false
      }
    }
  }
}
.onChange(of: notificationsEnabled) { enabled in
  guard let t = prayerTimes else { return }
  schedulePrayerNotifications(t)
  let center = UNUserNotificationCenter.current()
  if enabled {
    scheduleDhikrNotifications(t)
  } else {
    let ids = ["dhikr_ÿßŸÑŸÅÿ¨ÿ±","dhikr_ÿßŸÑÿ∏Ÿáÿ±","dhikr_ÿßŸÑÿπÿµÿ±","dhikr_ÿßŸÑŸÖÿ∫ÿ±ÿ®","dhikr_ÿßŸÑÿπÿ¥ÿßÿ°"]
    center.removePendingNotificationRequests(withIdentifiers: ids)
  }
}
.sheet(isPresented: $showSettings) {
  SettingsView()
}



.sheet(isPresented: $showEditIqama) {
  NavigationView {
    Form {
Section(
    header: Text(isArabic ? "ÿ™ÿπÿØŸäŸÑ ÿ£ŸàŸÇÿßÿ™ ÿßŸÑÿ•ŸÇÿßŸÖÿ©" : "Edit Iqama Times")
        .font(.headline),
    footer: Text(isArabic
        ? "ŸäŸÖŸÉŸÜŸÉ ŸÖÿπÿ±ŸÅÿ© ÿ™ŸàÿßŸÇŸäÿ™ ÿßŸÑÿ•ŸÇÿßŸÖÿ© ŸÖŸÜ ÿßŸÑŸàŸäÿ® ÿ£Ÿà ÿßŸÑÿ≥ÿßÿπÿßÿ™ ÿßŸÑŸÖŸàÿ¨ŸàÿØÿ© ŸÅŸä ÿßŸÑŸÖÿ≥ÿßÿ¨ÿØ"
        : "You can find the iqama times online or from the mosque clocks.")
        .font(.footnote)
        .foregroundColor(.gray)
) {
    // ŸÅÿ¨ÿ± / Fajr
    HStack {
        Stepper(
            isArabic
                ? "ÿßŸÑŸÅÿ¨ÿ±: \(tempIqamaFajrOffset) ÿØŸÇŸäŸÇÿ©"
                : "Fajr: \(tempIqamaFajrOffset) min",
            value: $tempIqamaFajrOffset,
            in: 0...60
        )
        .onChange(of: tempIqamaFajrOffset) { _ in
            if soundEnabled  { SoundPlayer.shared.play("click") }
            if hapticEnabled { UIImpactFeedbackGenerator(style: .light).impactOccurred() }
        }
        Button(isArabic ? "ÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä" : "Default") {
            tempIqamaFajrOffset = defaultIqamaOffsets.fajr
            if soundEnabled  { SoundPlayer.shared.play("click") }
            if hapticEnabled { UIImpactFeedbackGenerator(style: .light).impactOccurred() }
        }
        .font(.caption)
        .foregroundColor(.red)
        .buttonStyle(BorderlessButtonStyle())
    }

    // ÿßŸÑÿ∏Ÿáÿ± / Dhuhr
    HStack {
        Stepper(
            isArabic
                ? "ÿßŸÑÿ∏Ÿáÿ±: \(tempIqamaDhuhrOffset) ÿØŸÇŸäŸÇÿ©"
                : "Dhuhr: \(tempIqamaDhuhrOffset) min",
            value: $tempIqamaDhuhrOffset,
            in: 0...60
        )
        .onChange(of: tempIqamaDhuhrOffset) { _ in
            if soundEnabled  { SoundPlayer.shared.play("click") }
            if hapticEnabled { UIImpactFeedbackGenerator(style: .light).impactOccurred() }
        }
        Button(isArabic ? "ÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä" : "Default") {
            tempIqamaDhuhrOffset = defaultIqamaOffsets.dhuhr
            if soundEnabled  { SoundPlayer.shared.play("click") }
            if hapticEnabled { UIImpactFeedbackGenerator(style: .light).impactOccurred() }
        }
        .font(.caption)
        .foregroundColor(.red)
        .buttonStyle(BorderlessButtonStyle())
    }

    // ÿßŸÑÿπÿµÿ± / Asr
    HStack {
        Stepper(
            isArabic
                ? "ÿßŸÑÿπÿµÿ±: \(tempIqamaAsrOffset) ÿØŸÇŸäŸÇÿ©"
                : "Asr: \(tempIqamaAsrOffset) min",
            value: $tempIqamaAsrOffset,
            in: 0...60
        )
        .onChange(of: tempIqamaAsrOffset) { _ in
            if soundEnabled  { SoundPlayer.shared.play("click") }
            if hapticEnabled { UIImpactFeedbackGenerator(style: .light).impactOccurred() }
        }
        Button(isArabic ? "ÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä" : "Default") {
            tempIqamaAsrOffset = defaultIqamaOffsets.asr
            if soundEnabled  { SoundPlayer.shared.play("click") }
            if hapticEnabled { UIImpactFeedbackGenerator(style: .light).impactOccurred() }
        }
        .font(.caption)
        .foregroundColor(.red)
        .buttonStyle(BorderlessButtonStyle())
    }

    // ÿßŸÑŸÖÿ∫ÿ±ÿ® / Maghrib
    HStack {
        Stepper(
            isArabic
                ? "ÿßŸÑŸÖÿ∫ÿ±ÿ®: \(tempIqamaMaghribOffset) ÿØŸÇŸäŸÇÿ©"
                : "Maghrib: \(tempIqamaMaghribOffset) min",
            value: $tempIqamaMaghribOffset,
            in: 0...60
        )
        .onChange(of: tempIqamaMaghribOffset) { _ in
            if soundEnabled  { SoundPlayer.shared.play("click") }
            if hapticEnabled { UIImpactFeedbackGenerator(style: .light).impactOccurred() }
        }
        Button(isArabic ? "ÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä" : "Default") {
            tempIqamaMaghribOffset = defaultIqamaOffsets.maghrib
            if soundEnabled  { SoundPlayer.shared.play("click") }
            if hapticEnabled { UIImpactFeedbackGenerator(style: .light).impactOccurred() }
        }
        .font(.caption)
        .foregroundColor(.red)
        .buttonStyle(BorderlessButtonStyle())
    }

    // ÿßŸÑÿπÿ¥ÿßÿ° / Isha
    HStack {
        Stepper(
            isArabic
                ? "ÿßŸÑÿπÿ¥ÿßÿ°: \(tempIqamaIshaOffset) ÿØŸÇŸäŸÇÿ©"
                : "Isha: \(tempIqamaIshaOffset) min",
            value: $tempIqamaIshaOffset,
            in: 0...60
        )
        .onChange(of: tempIqamaIshaOffset) { _ in
            if soundEnabled  { SoundPlayer.shared.play("click") }
            if hapticEnabled { UIImpactFeedbackGenerator(style: .light).impactOccurred() }
        }
        Button(isArabic ? "ÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä" : "Default") {
            tempIqamaIshaOffset = defaultIqamaOffsets.isha
            if soundEnabled  { SoundPlayer.shared.play("click") }
            if hapticEnabled { UIImpactFeedbackGenerator(style: .light).impactOccurred() }
        }
        .font(.caption)
        .foregroundColor(.red)
        .buttonStyle(BorderlessButtonStyle())
    }
}
.environment(\.layoutDirection, isArabic ? .rightToLeft : .leftToRight)

            // MARK: ‚Äì ÿ™ÿπÿØŸäŸÑ ÿ£ŸàŸÇÿßÿ™ ÿßŸÑÿ£ÿ∞ÿßŸÜ
Section(
    header: Text(isArabic ? "ÿ™ÿπÿØŸäŸÑ ÿ£ŸàŸÇÿßÿ™ ÿßŸÑÿ£ÿ∞ÿßŸÜ" : "Edit Azan Times")
        .font(.headline),
    footer: Text(isArabic
        ? "ÿ®ÿπÿØ ÿßŸÑÿ™ÿπÿØŸäŸÑ ÿßŸÑŸàŸÇÿ™ ÿßÿ∞ÿßŸÜ Ÿäÿ™ŸÖ ÿ™ŸÑŸÇÿßÿ¶Ÿä ÿ≠ÿ≥ÿ® ÿßŸÑÿ™ŸàŸÇŸäÿ™ ÿ®ÿ¥ŸÉŸÑ ÿØŸÇŸäŸÇ ÿ®ÿπÿØ ÿ∞ÿßŸÑŸÉ ŸÑÿß ÿ™ÿ≠ÿ™ÿßÿ¨ ÿßŸÑŸâ ÿßŸÑÿ™ÿπÿØŸäŸÑ"
        : "After editing, azan times will update automatically according to accurate timings, so no further adjustments are needed.")
        .font(.footnote)
        .foregroundColor(.gray)
) {
    if let t = settingsTimings {
        // ÿ™ÿ≠ŸàŸäŸÑ ÿßŸÑÿ£ŸàŸÇÿßÿ™ ÿßŸÑÿ£ÿµŸÑŸäÿ© ÿ•ŸÑŸâ ÿµŸäÿ∫ÿ© 12-ÿ≥ÿßÿπÿ©
        let origFajr    = parser.date(from: t.fajr).map { formatter12.string(from: $0) } ?? t.fajr
        let origSunrise = parser.date(from: t.sunrise).map { formatter12.string(from: $0) } ?? t.sunrise
        let origDhuhr   = parser.date(from: t.dhuhr).map { formatter12.string(from: $0) } ?? t.dhuhr
        let origAsr     = parser.date(from: t.asr).map { formatter12.string(from: $0) } ?? t.asr
        let origMaghrib = parser.date(from: t.maghrib).map { formatter12.string(from: $0) } ?? t.maghrib
        let origIsha    = parser.date(from: t.isha).map { formatter12.string(from: $0) } ?? t.isha

        PrayerAzanRow(name: isArabic ? "ÿßŸÑŸÅÿ¨ÿ±" : "Fajr",
                      original: origFajr,
                      offset: $tempAzanFajrOffset)
        PrayerAzanRow(name: isArabic ? "ÿßŸÑÿ¥ÿ±ŸàŸÇ" : "Sunrise",
                      original: origSunrise,
                      offset: $tempAzanSunriseOffset)
        PrayerAzanRow(name: isArabic ? "ÿßŸÑÿ∏Ÿáÿ±" : "Dhuhr",
                      original: origDhuhr,
                      offset: $tempAzanDhuhrOffset)
        PrayerAzanRow(name: isArabic ? "ÿßŸÑÿπÿµÿ±" : "Asr",
                      original: origAsr,
                      offset: $tempAzanAsrOffset)
        PrayerAzanRow(name: isArabic ? "ÿßŸÑŸÖÿ∫ÿ±ÿ®" : "Maghrib",
                      original: origMaghrib,
                      offset: $tempAzanMaghribOffset)
        PrayerAzanRow(name: isArabic ? "ÿßŸÑÿπÿ¥ÿßÿ°" : "Isha",
                      original: origIsha,
                      offset: $tempAzanIshaOffset)
    } else {
        Text(isArabic ? "ÿ¨ÿßÿ±Ÿä ÿ™ÿ≠ŸÖŸäŸÑ ÿßŸÑÿ£ŸàŸÇÿßÿ™‚Ä¶" : "Loading times‚Ä¶")
            .foregroundColor(.gray)
    }
}
.environment(\.layoutDirection, isArabic ? .rightToLeft : .leftToRight)
.navigationTitle(isArabic ? "ÿ™ÿ≠ÿ±Ÿäÿ± ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™" : "Edit Settings")
.navigationBarItems(
    leading: Button(isArabic ? "ÿ•ŸÑÿ∫ÿßÿ°" : "Cancel") {
        showEditIqama = false
    },
    trailing: Button(isArabic ? "ÿ≠ŸÅÿ∏" : "Save") {
        // ÿ≠ŸÅÿ∏ ÿßŸÑŸÇŸäŸÖ ÿßŸÑÿ¨ÿØŸäÿØÿ©
        iqamaFajrOffset    = tempIqamaFajrOffset
        iqamaDhuhrOffset   = tempIqamaDhuhrOffset
        iqamaAsrOffset     = tempIqamaAsrOffset
        iqamaMaghribOffset = tempIqamaMaghribOffset
        iqamaIshaOffset    = tempIqamaIshaOffset

        azanFajrOffset     = tempAzanFajrOffset
        azanSunriseOffset  = tempAzanSunriseOffset
        azanDhuhrOffset    = tempAzanDhuhrOffset
        azanAsrOffset      = tempAzanAsrOffset
        azanMaghribOffset  = tempAzanMaghribOffset
        azanIshaOffset     = tempAzanIshaOffset

        // ÿ•ÿπÿßÿØÿ© ÿ¨ÿØŸàŸÑÿ© ÿßŸÑÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿ®ŸÜÿßÿ°Ÿã ÿπŸÑŸâ offsets ÿßŸÑÿ¨ÿØŸäÿØÿ©
        if let t = prayerTimes {
            schedulePrayerNotifications(t)
            if notificationsEnabled {
                scheduleDhikrNotifications(t)
            }
        }

        // ÿ•ÿ∫ŸÑÿßŸÇ ÿßŸÑÿ¥Ÿäÿ™
        showEditIqama = false
    }
)
.onAppear {
    // ÿ™ŸáŸäÿ¶ÿ© ÿßŸÑŸÇŸäŸÖ ÿßŸÑŸÖÿ§ŸÇÿ™ÿ© ÿπŸÜÿØ ŸÅÿ™ÿ≠ ÿßŸÑÿ¥Ÿäÿ™
    tempIqamaFajrOffset    = iqamaFajrOffset
    tempIqamaDhuhrOffset   = iqamaDhuhrOffset
    tempIqamaAsrOffset     = iqamaAsrOffset
    tempIqamaMaghribOffset = iqamaMaghribOffset
    tempIqamaIshaOffset    = iqamaIshaOffset

    tempAzanFajrOffset     = azanFajrOffset
    tempAzanSunriseOffset  = azanSunriseOffset
    tempAzanDhuhrOffset    = azanDhuhrOffset
    tempAzanAsrOffset      = azanAsrOffset
    tempAzanMaghribOffset  = azanMaghribOffset
    tempAzanIshaOffset     = azanIshaOffset

    if let _ = locationManager.location {
        PrayerTimesServiceOffline.shared.getPrayerTimes(date: Date()) { newTimings in
            DispatchQueue.main.async {
                settingsTimings = newTimings
                // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ£ŸàŸÇÿßÿ™ ÿßŸÑÿ£ÿµŸÑŸäÿ© ŸÅŸä ÿßŸÑÿµŸäÿ∫ÿ© 12-ÿ≥ÿßÿπÿ©
                if let d = parser.date(from: newTimings.fajr)    { origFajr    = formatter12.string(from: d) }
                if let d = parser.date(from: newTimings.sunrise) { origSunrise = formatter12.string(from: d) }
                if let d = parser.date(from: newTimings.dhuhr)   { origDhuhr   = formatter12.string(from: d) }
                if let d = parser.date(from: newTimings.asr)     { origAsr     = formatter12.string(from: d) }
                if let d = parser.date(from: newTimings.maghrib) { origMaghrib = formatter12.string(from: d) }
                if let d = parser.date(from: newTimings.isha)    { origIsha    = formatter12.string(from: d) }
            }
        }
    }
}



}
.accentColor(.primary)
.buttonStyle(SoundButtonStyle())
.preferredColorScheme(darkModeEnabled ? .dark : .light)
    }
}
}
}


}



// 1) ÿ∂ÿπ Ÿáÿ∞ÿß ÿßŸÑÿ™ÿπÿ±ŸäŸÅ ŸÅŸàŸÇ ContentView ÿ£Ÿà ŸÅŸä ŸÜŸáÿßŸäÿ© ÿßŸÑŸÖŸÑŸÅ:
private struct PrayerAzanRow: View {
    let name: String
    let original: String    // ŸÜÿµ ÿßŸÑŸàŸÇÿ™ ÿ®ÿµŸäÿ∫ÿ© 12-ÿ≥ÿßÿπÿ©
    @Binding var offset: Int

    @AppStorage("soundEnabled")  private var soundEnabled  = false
    @AppStorage("hapticEnabled") private var hapticEnabled = true
    @AppStorage("selectedLanguage") private var selectedLanguage: String = Locale.current.language.languageCode?.identifier ?? "en"

    private var isArabic: Bool {
        selectedLanguage == "ar"
    }

    private let parser: DateFormatter = {
        let f = DateFormatter()
        f.locale     = Locale(identifier: "en_US_POSIX")
        f.dateFormat = "h:mm a"
        f.amSymbol = "ÿµ"; f.pmSymbol = "ŸÖ"
        return f
    }()
    private let formatter12: DateFormatter = {
        let f = DateFormatter()
        f.locale     = Locale(identifier: "en_US_POSIX")
        f.dateFormat = "h:mm a"
        f.amSymbol = "ÿµ"; f.pmSymbol = "ŸÖ"
        return f
    }()

    private var original12: String {
        guard let d = parser.date(from: original) else { return original }
        return formatter12.string(from: d)
    }
    private var adjusted12: String {
        guard let d = parser.date(from: original) else { return original12 }
        let adjDate = Calendar.current.date(byAdding: .minute, value: offset, to: d) ?? d
        return formatter12.string(from: adjDate)
    }

    var body: some View {
        HStack {
            VStack(alignment: .leading, spacing: 2) {
                Text(name)
                    .font(.body).bold()

                Text(isArabic
                    ? "ÿßŸÑÿ£ÿ≥ÿßÿ≥Ÿä: \(original12)"
                    : "Original: \(original12)"
                )
                .font(.caption)
                .foregroundColor(.gray)

                Text(isArabic
                    ? "ÿ®ÿπÿØ ÿßŸÑÿ™ÿπÿØŸäŸÑ: \(adjusted12)"
                    : "Adjusted: \(adjusted12)"
                )
                .font(.caption.monospacedDigit())
                .foregroundColor(.green)
            }
            Spacer()
            HStack(spacing: 12) {
                Stepper("", value: $offset, in: -60...60)
                    .labelsHidden()
                    .frame(minWidth: 80)
                    .onChange(of: offset) { _ in
                        if soundEnabled  { SoundPlayer.shared.play("click") }
                        if hapticEnabled { UIImpactFeedbackGenerator(style: .light).impactOccurred() }
                    }

                Button(isArabic ? "ÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä" : "Default") {
                    offset = 0
                    if soundEnabled  { SoundPlayer.shared.play("click") }
                    if hapticEnabled { UIImpactFeedbackGenerator(style: .light).impactOccurred() }
                }
                .font(.caption)
                .foregroundColor(.red)
                .buttonStyle(BorderlessButtonStyle())
            }
        }
        .padding(.vertical, 4)
        .environment(\.layoutDirection, isArabic ? .rightToLeft : .leftToRight)
    }
}
    
    














                        struct DhikrCard: View {
                            let type: DhikrType
                            let fontSize: CGFloat

                            var body: some View {
                                HStack {
                                    Image(systemName: type.icon)
                                        .font(.system(size: fontSize))
                                        .foregroundColor(.white)
                                        .frame(width: fontSize*2, height: fontSize*2)
                                        .background(type.color)
                                        .clipShape(Circle())
                                    Text(type.rawValue)
                                        .font(.system(size: fontSize, weight:.semibold))
                                        .foregroundColor(.white)
                                        .padding(.leading,10)
                                    Spacer()
                                    Image(systemName: "chevron.left")
                                        .font(.system(size: fontSize*0.8))
                                        .foregroundColor(.gray)
                                }
                                .padding(18)
                                .background(Color.black.opacity(0.4))
                                .cornerRadius(20)
                            }
                        }

                        //ŸáŸÜÿß 55

                        // MARK: - DhikrDetailView


                        // MARK: - AddDhikrView



                        // 1) ÿ∂ÿπ Ÿáÿ∞ÿß ÿÆÿßÿ±ÿ¨ ÿ£Ÿä struct ÿ¢ÿÆÿ±:
                        struct CustomTextView: UIViewRepresentable {
                            @Binding var text: String
                            var placeholder: String
                            var textColor: UIColor = .label  // ÿßŸÑÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä ÿ£ÿ≥ŸàÿØ

                            func makeUIView(context: Context) -> UITextView {
                                let tv = UITextView()
                                tv.delegate = context.coordinator
                                tv.font = .systemFont(ofSize: 16)
                                tv.text = text.isEmpty ? placeholder : text
                                tv.textColor = text.isEmpty ? .gray : textColor
                                return tv
                            }

                            func updateUIView(_ uiView: UITextView, context: Context) {
                                uiView.text = text.isEmpty ? placeholder : text
                                uiView.textColor = text.isEmpty ? .gray : textColor
                            }

                            func makeCoordinator() -> Coordinator {
                                Coordinator(self)
                            }

                            class Coordinator: NSObject, UITextViewDelegate {
                                var parent: CustomTextView
                                init(_ parent: CustomTextView) { self.parent = parent }

                                func textViewDidBeginEditing(_ textView: UITextView) {
                                    if textView.text == parent.placeholder {
                                        textView.text = ""
                                        textView.textColor = parent.textColor
                                    }
                                }

                                func textViewDidChange(_ textView: UITextView) {
                                    parent.text = textView.text
                                }

                                func textViewDidEndEditing(_ textView: UITextView) {
                                    if textView.text.isEmpty {
                                        textView.text = parent.placeholder
                                        textView.textColor = .gray
                                    }
                                }
                            }
                        }









struct SettingsView: View {
    // MARK: ‚Äì AppStorage
    @AppStorage("notificationsEnabled") private var notificationsEnabled = true
    @AppStorage("darkModeEnabled")    private var darkModeEnabled    = true
    @AppStorage("soundEnabled")       private var soundEnabled       = false
    @AppStorage("hapticEnabled")      private var hapticEnabled      = true
    @AppStorage("selectedLanguage")   private var selectedLanguage   = Locale
        .current
        .language
        .languageCode?
        .identifier
        ?? "ar"

    // MARK: ‚Äì Environment
    @Environment(\.presentationMode) var presentationMode
    @Environment(\.colorScheme)    var colorScheme

    // MARK: ‚Äì Share & Suggestion State
    @State private var isSharePresented   = false
    @State private var isSuggestPresented = false
    @State private var suggestionText     = ""

    private var shareText: String {
        selectedLanguage == "ar"
            ? "ÿ¨ÿ±ÿ® ÿ™ÿ∑ÿ®ŸäŸÇ ÿ£ÿ∞ÿßŸÜ Ÿàÿ£ÿ∞ŸÉÿßÿ± ÿßŸÑŸÖÿ≥ŸÑŸÖ ÿßŸÑÿ±ÿßÿ¶ÿπ!"
            : "Try the amazing Muslim prayer & dhikr app!"
    }
    private let shareURL = URL(string:
        "https://tools4cydia.info/filetools/ipa/Salatuk%20Pro.ipa"
    )!

    // MARK: ‚Äì Translations
    private var t_settings: String       { selectedLanguage == "ar" ? "ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™"          : "Settings" }
    private var t_general: String        { selectedLanguage == "ar" ? "ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑÿπÿßŸÖÿ©"   : "General Settings" }
    private var t_dhikrNotif: String     { selectedLanguage == "ar" ? "ÿ•ÿ¥ÿπÿßÿ±ÿßÿ™ ÿßŸÑÿ£ÿ∞ŸÉÿßÿ±"    : "Dhikr Notifications" }
    private var t_touchSounds: String    { selectedLanguage == "ar" ? "ÿ£ÿµŸàÿßÿ™ ÿßŸÑŸÑŸÖÿ≥"         : "Touch Sounds" }
    private var t_haptic: String         { selectedLanguage == "ar" ? "ÿßŸÑÿßŸáÿ™ÿ≤ÿßÿ≤"            : "Haptic Feedback" }
    private var t_darkMode: String       { selectedLanguage == "ar" ? "ÿßŸÑŸàÿ∂ÿπ ÿßŸÑŸÑŸäŸÑŸä"        : "Dark Mode" }
    private var t_language: String       { selectedLanguage == "ar" ? "ÿßŸÑŸÑÿ∫ÿ©"               : "Language" }
    private var t_about: String          { selectedLanguage == "ar" ? "ÿ≠ŸàŸÑ ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ"         : "About" }
    private var t_version: String        { selectedLanguage == "ar" ? "ÿßŸÑÿ•ÿµÿØÿßÿ±"             : "Version" }
    private var t_addSuggestion: String  { selectedLanguage == "ar" ? "ÿ£ÿ∂ŸÅ ÿßŸÇÿ™ÿ±ÿßÿ≠"          : "Add Suggestion" }
    private var t_shareApp: String       { selectedLanguage == "ar" ? "ŸÖÿ¥ÿßÿ±ŸÉÿ© ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ"      : "Share App" }
    private var t_contactUs: String      { selectedLanguage == "ar" ? "ÿ™ŸàÿßÿµŸÑ ŸÖÿπŸÜÿß"          : "Contact Us" }
    private var t_twitter: String        { selectedLanguage == "ar" ? "ÿ™ŸàŸäÿ™ÿ±"               : "Twitter" }
    private var t_done: String           { selectedLanguage == "ar" ? "ÿ™ŸÖ"                  : "Done" }
    private var t_cancel: String         { selectedLanguage == "ar" ? "ÿ•ŸÑÿ∫ÿßÿ°"               : "Cancel" }
    private var t_send: String           { selectedLanguage == "ar" ? "ÿ•ÿ±ÿ≥ÿßŸÑ"               : "Send" }
    private var t_suggestPrompt: String  { selectedLanguage == "ar"
        ? "ÿ¥ÿßÿ±ŸÉŸÜÿß ÿ£ŸÅŸÉÿßÿ±ŸÉ ŸÑÿ™ÿ≠ÿ≥ŸäŸÜ ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇ"
        : "Share your ideas to improve the app"
    }
    private var t_newSuggestion: String  { selectedLanguage == "ar" ? "ÿßŸÇÿ™ÿ±ÿßÿ≠ ÿ¨ÿØŸäÿØ"         : "New Suggestion" }

    var body: some View {
        NavigationView {
            Form {
                // MARK: - General Settings
                Section(header: sectionHeader(title: t_general, icon: "gearshape.fill")) {
                    SettingRow(icon: "bell.fill", color: .red,    title: t_dhikrNotif,  toggle: $notificationsEnabled)
                    SettingRow(icon: "speaker.wave.2.fill", color: .blue, title: t_touchSounds, toggle: $soundEnabled)
                    SettingRow(icon: "iphone.radiowaves.left.and.right", color: .green, title: t_haptic,      toggle: $hapticEnabled)
                    SettingRow(icon: "moon.fill", color: .purple, title: t_darkMode,     toggle: $darkModeEnabled)

                    // MARK: - Language Selection Row
                    Menu {
                        Button("ÿßŸÑÿπÿ±ÿ®Ÿäÿ©") {
                            selectedLanguage = "ar"
                            if soundEnabled { SoundPlayer.shared.play("click") }
                        }
                        Button("English") {
                            selectedLanguage = "en"
                            if soundEnabled { SoundPlayer.shared.play("click") }
                        }
                    } label: {
HStack {
                        Text(t_language)
                        Spacer()
                        Text(selectedLanguage == "ar" ? "ÿßŸÑÿπÿ±ÿ®Ÿäÿ©" : "English")
                            .foregroundColor(.secondary)
                        Image(systemName: "globe.europe.africa")
                            .foregroundColor(.blue)
                    }
                    .padding(.vertical, 8)
                }
}

                // MARK: - About
                Section(header: sectionHeader(title: t_about, icon: "info.circle.fill")) {
                    InfoRow(title: t_version, value: "3.6.0")
                    ActionRow(icon: "lightbulb.fill", color: .orange, title: t_addSuggestion) {
                        isSuggestPresented = true
                    }
                }

                // MARK: - Share App
                Section {
                    ActionRow(icon: "square.and.arrow.up.fill", color: .green, title: t_shareApp) {
                        isSharePresented = true
                    }
                    .sheet(isPresented: $isSharePresented) {
                        ActivityView(activityItems: [shareText, shareURL])
                    }
                }

                // MARK: - Contact Us
                Section(header: sectionHeader(title: t_contactUs, icon: "envelope.fill")) {
                    SocialMediaRow(
                        icon: "x.circle.fill",
                        color: .black,
                        title: t_twitter,
                        handle: "@Tools4cydia",
                        url: "https://twitter.com/Tools4cydia"
                    )
                    SocialMediaRow(
                        icon: "x.circle.fill",
                        color: .black,
                        title: t_twitter,
                        handle: "@Salatuk_Pro",
                        url: "https://twitter.com/Salatuk_Pro"
                    )
                }
            }
            .navigationBarTitle(t_settings, displayMode: .inline)
            .navigationBarItems(trailing: doneButton)
            .background(backgroundView)
            .sheet(isPresented: $isSuggestPresented) { suggestionSheet }
        }
        .accentColor(colorScheme == .dark ? .white : .blue)
        .environment(\.layoutDirection, .leftToRight)
        .preferredColorScheme(darkModeEnabled ? .dark : .light)
    }

    // MARK: - Done Button
    private var doneButton: some View {
        Button(t_done) {
            presentationMode.wrappedValue.dismiss()
        }
        .fontWeight(.medium)
        .buttonStyle(SoundButtonStyle())
    }

    // MARK: - Background
    private var backgroundView: some View {
        Color.clear
            .background(
                colorScheme == .dark
                    ? LinearGradient(
                        gradient: Gradient(colors: [Color.black.opacity(0.9), Color.gray.opacity(0.2)]),
                        startPoint: .top, endPoint: .bottom
                      )
                    : LinearGradient(
                        gradient: Gradient(colors: [Color.white.opacity(0.9), Color.gray.opacity(0.1)]),
                        startPoint: .top, endPoint: .bottom
                      )
            )
    }

    // MARK: - Suggestion Sheet
    private var suggestionSheet: some View {
        NavigationView {
            VStack(alignment: .leading, spacing: 16) {
                Text(t_suggestPrompt)
                    .font(.headline)
                    .padding(.top, 20)
                TextEditor(text: $suggestionText)
                    .frame(minHeight: 150)
                    .padding(10)
                    .background(
                        RoundedRectangle(cornerRadius: 12)
                            .strokeBorder(Color.gray.opacity(0.3), lineWidth: 1)
                    )
                    .padding(.horizontal)
                    .shadow(color: Color.black.opacity(0.05), radius: 5, x: 0, y: 2)
                Spacer()
            }
            .padding(.horizontal)
            .navigationBarTitle(t_newSuggestion, displayMode: .inline)
            .navigationBarItems(
                leading: Button(t_cancel) {
                    suggestionText = ""
                    isSuggestPresented = false
                },
                trailing: Button(t_send) {
                    sendSuggestion()
                }
                .disabled(suggestionText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)
            )
        }
    }

    // MARK: - Section Header Helper
    private func sectionHeader(title: String, icon: String) -> some View {
        HStack {
            Spacer()
            HStack(spacing: 8) {
                Text(title)
                    .font(.headline)
                Image(systemName: icon)
                    .foregroundColor(.accentColor)
            }
            .padding(.vertical, 8)
        }
    }

    // MARK: - Suggestion Email Action
    private func sendSuggestion() {
        let email = "salatuk.t4c@gmail.com"
        let subject = selectedLanguage == "ar"
            ? "ÿßŸÇÿ™ÿ±ÿßÿ≠ ŸÖŸÜ ŸÖÿ≥ÿ™ÿÆÿØŸÖ"
            : "Suggestion from User"
        let body = suggestionText
        let escSub = subject.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? ""
        let escBody = body.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? ""
        if let url = URL(string: "mailto:\(email)?subject=\(escSub)&body=\(escBody)") {
            UIApplication.shared.open(url)
        }
        suggestionText = ""
        isSuggestPresented = false
    }
}


// ÿ´ŸÖ ÿ£ÿπÿØ ÿ™ÿ¥ÿ∫ŸäŸÑ ÿßŸÑÿ™ÿ∑ÿ®ŸäŸÇÿå ŸàŸäÿ¨ÿ® ÿ£ŸÜ Ÿäÿ™ŸàŸÇŸÅ ÿßŸÑŸÄ crash ÿπŸÜÿØ ŸÅÿ™ÿ≠ ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™.


// MARK: - Custom Rows

struct SettingRow: View {
    let icon: String
    let color: Color
    let title: String
    @Binding var toggle: Bool

    var body: some View {
        HStack {
            Toggle("", isOn: $toggle)
                .toggleStyle(SwitchToggleStyle(tint: color))
                .labelsHidden()
                .padding(.trailing, 8)
            Text(title)
                .frame(maxWidth: .infinity, alignment: .trailing)
            Image(systemName: icon)
                .foregroundColor(color)
                .frame(width: 24, height: 24)
        }
        .padding(.vertical, 8)
    }
}

struct InfoRow: View {
    let title: String
    let value: String

    var body: some View {
        HStack {
            Text(value)
                .foregroundColor(.secondary)
            Spacer()
            Text(title)
                .frame(alignment: .trailing)
        }
        .padding(.vertical, 8)
    }
}

struct ActionRow: View {
    let icon: String
    let color: Color
    let title: String
    let action: () -> Void

    var body: some View {
        Button(action: action) {
            HStack {
                Image(systemName: "chevron.left")
                    .foregroundColor(.gray)
                    .padding(.trailing, 8)
                Text(title)
                    .foregroundColor(.primary)
                    .frame(maxWidth: .infinity, alignment: .trailing)
                Image(systemName: icon)
                    .foregroundColor(color)
                    .frame(width: 24, height: 24)
            }
            .padding(.vertical, 8)
        }
        .buttonStyle(SoundButtonStyle())
    }
}

struct SocialMediaRow: View {
    let icon: String
    let color: Color
    let title: String
    let handle: String
    let url: String

    var body: some View {
        Button(action: {
            if let u = URL(string: url) { UIApplication.shared.open(u) }
        }) {
            HStack {
                Image(systemName: "arrow.up.left")
                    .foregroundColor(.gray)
                    .padding(.trailing, 8)
                VStack(alignment: .trailing, spacing: 2) {
                    Text(title)
                        .foregroundColor(.primary)
                    Text(handle)
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                .frame(maxWidth: .infinity, alignment: .trailing)
                Image(systemName: icon)
                    .foregroundColor(color)
                    .frame(width: 24, height: 24)
            }
            .padding(.vertical, 8)
        }
        .buttonStyle(SoundButtonStyle())
    }
}

struct SettingsView_Previews: PreviewProvider {
    static var previews: some View {
        SettingsView()
            .preferredColorScheme(.light)
        SettingsView()
            .preferredColorScheme(.dark)
    }
}




    // MARK: - Previews

    struct ContentView_Previews: PreviewProvider {
        static var previews: some View {
            ContentView()
        }
    }
